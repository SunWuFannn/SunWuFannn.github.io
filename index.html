<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="一个让人日常头秃的笔记" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     小张日记
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/main.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="小张日记" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover6.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">小张日记</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-javaweb_HTTP" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/javaweb_HTTP/"
    >JavaWeb中HTTP相关的粗略描述</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/javaweb_HTTP/" class="article-date">
  <time datetime="2020-05-07T16:00:00.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h1><ul>
<li><p>概念：Hyper Text Transfer Protocol 超文本传输协议</p>
<ul>
<li>传输协议：定义了客户端和服务器通信时，发送数据的格式。</li>
<li>特点：<ol>
<li>基于TCP/IP的高级协议</li>
<li>默认端口号：80</li>
<li>基于请求/响应模型的：一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
</li>
</ul>
</li>
<li><p>历史版本：</p>
<ul>
<li>1.0：每次请求响应都会建立新的连接</li>
<li>1.1：复用连接</li>
</ul>
</li>
</ul>
<hr>
<h3 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h3><ol>
<li><p>请求行</p>
<ul>
<li>请求方式 请求url 请求协议/版本</li>
<li>如：GET /login.html HTTP/1.1</li>
<li>请求方式：<ul>
<li>HTTP有7种请求方式，常见的有两种：<ul>
<li>GET：请求参数在请求行中，在url后。请求的url长度是有限制的。不太安全。</li>
<li>POST：请求参数在请求体中。请求的url长度是无限制的。相对安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头：客户端浏览器告诉服务器一些信息</p>
<ul>
<li>请求头名：请求头值</li>
<li>常见的请求头：<ol>
<li>Host: 主机</li>
<li>User-Agent: 浏览器告诉服务器，我访问你使用的浏览器版本信息<ul>
<li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li>
</ul>
</li>
<li>Referer: 告诉服务器，当前请求从哪里来<ul>
<li>作用：<ol>
<li>防盗链：</li>
<li>统计工作：</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>请求空行：空行，用于分割post请求头和请求体的</p>
</li>
<li><p>请求体（正文）</p>
<ul>
<li>封装post请求消息的请求参数的</li>
</ul>
</li>
</ol>
<hr>
<h3 id="响应消息数据格式"><a href="#响应消息数据格式" class="headerlink" title="响应消息数据格式"></a>响应消息数据格式</h3><ol>
<li>响应行：<ul>
<li>组成：协议/版本 响应状态码 状态码描述</li>
<li>响应状态码：服务器告诉客户端浏览器本次请求和响应的状态，状态码都是三位数字<ul>
<li>状态分类：<ol>
<li>1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后发送1xx的状态码</li>
<li>2xx：成功。代表：200</li>
<li>3xx：重定向。代表：302（重定向），304（访问缓存）</li>
<li>4xx：客户端错误。代表：404（请求路径没有对应的资源），405（请求方式没有对应的方法）</li>
<li>5xx：服务器端错误。代表：500（服务器内部出现异常）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>响应头<ul>
<li>格式：头名称:值</li>
<li>常见的响应头：<ol>
<li>Content-Type：服务器告诉客户端浏览器本次响应体的数据格式及编码格式</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据。默认值是<code>in-line 在当前页面内打开</code>，可以设置为<code>attachment;filename=xxx 以附件形式打开响应体</code></li>
</ol>
</li>
</ul>
</li>
<li>响应空行</li>
<li>响应体：传输的数据</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Request" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/Request/"
    >Request</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/Request/" class="article-date">
  <time datetime="2020-05-07T16:00:00.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><p>Request和Response对象的原理：</p>
<ol>
<li>Request和Response对象是由服务器创建的。我们来使用它们。</li>
<li>Request对象来获取请求消息，Response对象来设置响应消息。</li>
</ol>
<h3 id="Request对象继承体系结构"><a href="#Request对象继承体系结构" class="headerlink" title="Request对象继承体系结构"></a>Request对象继承体系结构</h3><p>HttpServletRequest接口继承ServletRequest接口。<br>org.apache.catalina.connector.RequestFacade类（tomcat实现）实现HttpServletRequest接口。</p>
<h3 id="Request功能："><a href="#Request功能：" class="headerlink" title="Request功能："></a>Request功能：</h3><ol>
<li><p>获取请求消息数据：</p>
<ol>
<li>获取请求行数据：<ul>
<li>方法：<ol>
<li>获取请求方式：String getMethod()</li>
<li>获取虚拟目录：String getContextPath()</li>
<li>获取Servlet路径：String getServletPath()</li>
<li>获取<strong>GET方式请求参数：String getQueryString()</strong></li>
<li>获取请求URI：<ul>
<li>String getRequestURI()：返回虚拟目录加servlet路径</li>
<li>String getRequestURI()：返回浏览器地址栏中的地址，即http://…….形式的</li>
</ul>
</li>
<li>获取协议及版本：String getProtocol()</li>
<li>获取客户机ip地址：String getRemoteAddr()</li>
</ol>
</li>
</ul>
</li>
<li>获取请求头数据：<ul>
<li>方法：<ul>
<li>String getHeader(String name)：通过请求头的名称获取请求头的值</li>
<li>Enmueration&lt; string&gt; getHeaderNames()：获取所有请求头的名称</li>
</ul>
</li>
</ul>
</li>
<li>获取请求体数据：<ul>
<li>请求体只有在POST请求方式中才有，请求体中封装了POST请求的参数</li>
<li>步骤：<ol>
<li>获取流对象<ul>
<li>BufferedReader getReader()：获取字符输入流，只能操作字符数据</li>
<li>ServletInputStream getInputStream()：获取字节输入流，可以操作所有数据类型数据</li>
</ul>
</li>
<li>再从流对象中拿数据</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>其他功能：</p>
<ol>
<li><p>获取请求参数通用方式：</p>
<ol>
<li>String getParameter(String name)：根据参数名称获取参数值</li>
<li>String[] getParameterValues(String name)：根据参数名称获取参数值的数组</li>
<li>Enmueration&lt; string&gt; getParameterNames()：获取所有请求的参数名称</li>
<li>Map&lt; String, String[]&gt; getParameterMap()：获取所有参数的Map集合</li>
</ol>
<ul>
<li>中文乱码问题：<ul>
<li>get方式：tomcat8已经将get方式乱码问题解决了</li>
<li>post方式：在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>请求转发：一种在服务器内部的资源跳转方式</p>
<ul>
<li>步骤：<ol>
<li>通过request对象获取请求转发对象：RequestDispatcher getRequestDispatcher(String path)</li>
<li>使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)</li>
</ol>
</li>
<li>特点：<ol>
<li>浏览器地址栏路径不发生变化</li>
<li>只能转发到当前服务器内部资源中</li>
<li>转发是一次请求</li>
</ol>
</li>
</ul>
</li>
<li><p>共享数据：</p>
<ul>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域：代表一次请求的范围，一般用于请求转发中的多个资源中共享数据</li>
<li>方法：<ol>
<li>void setAttribute(String name, Object obj)：存储数据</li>
<li>Object getAttribute(String name)：通过键获取值</li>
<li>void removeAttribute(String name)：通过键移除键值对</li>
</ol>
</li>
</ul>
</li>
<li><p>获取ServletContext：</p>
<ul>
<li>ServletContext getServletContext()</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="BeanUtils工具类，简化数据封装"><a href="#BeanUtils工具类，简化数据封装" class="headerlink" title="BeanUtils工具类，简化数据封装"></a>BeanUtils工具类，简化数据封装</h3><ul>
<li><p>用于封装JavaBean的</p>
</li>
<li><p><strong>JavaBean：标准的java类</strong></p>
<ul>
<li><p>要求：</p>
<ol>
<li>类必须被public修饰</li>
<li>必须提供空参的构造器</li>
<li>成员变量必须使用private修饰</li>
<li>提供public修饰的getter和setter</li>
</ol>
</li>
<li><p>功能：封装数据</p>
</li>
</ul>
</li>
<li><p>概念：</p>
<ul>
<li><p>成员变量</p>
</li>
<li><p>属性：setter和getter方法截取后的产物</p>
<ul>
<li><p>如</p>
<pre><code>public void setHehe(String gender){
     this.gender = gender;
}</code></pre></li>
<li><p>其中成员变量是gender，属性是hehe</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方法：</p>
<ol>
<li>setProperty()：设置JavaBean对象属性值</li>
<li>getProperty()：获取JavaBean对象属性值</li>
<li>populate(Object obj，Map map)：将map集合的键值对信息封装到对于的JavaBean对象中</li>
</ol>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Request/" rel="tag">Request</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Response" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/Response/"
    >Response</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/Response/" class="article-date">
  <time datetime="2020-05-07T16:00:00.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><ul>
<li><strong>设置响应消息：</strong><ol>
<li>设置响应行<ul>
<li>设置状态码：setStatus(int sc)</li>
</ul>
</li>
<li>设置响应头<ul>
<li>setHeader(Sting name, Sring value)</li>
</ul>
</li>
<li>设置响应体：<ul>
<li>使用步骤：<ol>
<li>获取输出流</li>
<li>使用输出流将数据输出到客户端浏览器</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><ol>
<li>完成重定向</li>
</ol>
<ul>
<li><p>重定向：资源跳转的方式</p>
</li>
<li><p>代码：</p>
<pre><code>//设置状态码
resp.setStatus(302);
//设置重定向资源location路径
resp.setHeader(&quot;location&quot;,&quot;/javaweb_tomcat_war_exploded/ResponseDemo02&quot;);</code></pre></li>
<li><p>简化写法：<code>resp.sendRedirect(&quot;/javaweb_tomcat_war_exploded/ResponseDemo02&quot;);</code></p>
</li>
<li><p>重定向的特点：</p>
<ol>
<li>浏览器地址栏发生变化</li>
<li>重定向可以访问其他站点（服务器）的资源</li>
<li>重定向是两次请求，不能使用request对象共享数据</li>
</ol>
</li>
<li><p>路径写法：</p>
<ol>
<li>路径分类：<ol>
<li>相对路径：通过相对路径不可以确定唯一资源<ul>
<li>如：./index.html</li>
<li>不以/开业，以.开头的路径</li>
<li>规则：找到当前资源和目标资源之间的关系<ul>
<li>./：当前目录</li>
<li>../：后退一级目录</li>
</ul>
</li>
</ul>
</li>
<li>绝对路径：通过相对路径可以确定唯一资源<ul>
<li>如：<a href="http://localhost/day15/responseDemo2" target="_blank" rel="noopener">http://localhost/day15/responseDemo2</a></li>
<li>以/开头的路径</li>
<li>规则：判断定义的路径给谁用<ul>
<li>给客户端浏览器使用：需要加虚拟目录（项目的访问路径）<ul>
<li>建议虚拟目录动态获取：<code>request.getContextPath()</code></li>
</ul>
</li>
<li>给服务使用：不需要加虚拟目录</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>服务器输出字符数据到浏览器</p>
<ul>
<li>步骤：<ol>
<li>获取字符输出流</li>
<li>输出数据</li>
</ol>
</li>
<li><strong>注意：乱码问题</strong><ul>
<li>获取的流的默认编码格式是ISO-8859-1，需要设置该流的默认编码，告诉浏览器响应体使用的编码。</li>
<li><code>resp.setContentType(&quot;text/html;charset=utf-8&quot;);</code>在获取流之前设置</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器输出字节数据到浏览器</p>
<ul>
<li>步骤：<ol>
<li>获取字节输出流</li>
<li>输出数据</li>
</ol>
</li>
</ul>
</li>
<li><p>验证码</p>
<pre><code>public class CheckCodeServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    int width = 100;
    int height = 50;

    //创建对象，在内存中和代表图片（验证码图片对象）
    BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
    //美化图片
    //获取画笔对象
    Graphics graphics = bufferedImage.getGraphics();
    //设置填充的背景色
    graphics.setColor(Color.PINK);
    //设置填充开始的坐标以及宽度高度，填充一个矩形
    graphics.fillRect(0, 0, width, height);
    //设置边框的颜色
    graphics.setColor(Color.BLUE);
    //从坐标处画一个边框，因为边框的有1px的宽度，所有宽度和高度要减去1
    graphics.drawRect(0, 0, width - 1, height - 1);
    //设置验证码的颜色
    graphics.setColor(new Color(214, 24, 215));
    //随机生成4个验证码，放入图中
    String str = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm0123456789&quot;;
    Random random = new Random();
    for (int i = 1; i &lt;= 4; i++) {
        int index = random.nextInt(str.length());
        char ch = str.charAt(index);
        graphics.drawString(ch + &quot;&quot;, width / 5 * i, height / 2);
    }
    //设置干扰线的颜色
    graphics.setColor(Color.RED);
    //随机生成10条干扰线放入图中
    for (int i = 0; i &lt; 10; i++) {
        int x1 = random.nextInt(width);
        int y1 = random.nextInt(height);
        int x2 = random.nextInt(width);
        int y2 = random.nextInt(height);
        graphics.drawLine(x1, y1, x2, y2);
    }
    //将图片输出到页面
    ImageIO.write(bufferedImage, &quot;jpg&quot;, resp.getOutputStream());
}</code></pre></li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Response/" rel="tag">Response</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Bootstrap" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/05/Bootstrap/"
    >Bootstrap</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/05/Bootstrap/" class="article-date">
  <time datetime="2020-05-04T16:00:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Bootstrap/">Bootstrap</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><ul>
<li><p>概念：一个前端开发的框架。Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。</p>
<ul>
<li>框架：一个半成品软件。开发人员可以在框架基础上再进行开发，简化编码。</li>
<li>好处：<ol>
<li>定义了很多的css样式和js插件。我们开发人员可以直接使用这些样式和插件得到丰富的页面效果。</li>
<li>响应式布局。<ul>
<li>同一套页面可以兼容不同分辨率的设备。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li>下载Bootstrap</li>
<li>在项目中将下载解压完的文件中的三个文件夹复制</li>
<li>创建html页面，引入必要的资源文件</li>
</ol>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><ul>
<li><p><strong>实现</strong>：依赖于栅格系统。</p>
<ul>
<li>栅格系统：将一行平均分割成12个格子，可以指定元素占几个格子。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>定义容器<ul>
<li>容器分类：<ol>
<li>container：固定宽度。每一种设备的宽度都是一个不同的固定值</li>
<li>container-fluid：每一种设备都是100%宽度</li>
</ol>
</li>
</ul>
</li>
<li>定义行 样式：row</li>
<li>定义元素。指定该元素在不同的设备上占用的格子数目 样式：col-设备代号-格子数目<ul>
<li>设备代号：<ol>
<li>xs：超小屏幕 手机(&lt;768px)</li>
<li>sm：小屏幕 平板(&gt;=768px)</li>
<li>md：中等屏幕 桌面显示器(&gt;=992px)</li>
<li>lg：大屏幕 大桌面显示器(&gt;=1200px)</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>注意：</strong><ol>
<li>一行中如果格子数目超过12，则超出部分自动换行</li>
<li>栅格类属性可以向上兼容</li>
<li>如果真实设备的宽度小于了设置的栅格类属性的设备代码的最小值，会一个元素占满一整行</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><p>全局CSS样式：</p>
<ul>
<li>按钮：例如 <code>btn btn-default</code></li>
<li>图片：<ul>
<li>响应式图片 <code>class=&quot;img-responsive&quot;</code></li>
<li>图片形状例如 <code>class=&quot;img-rounded&quot;</code></li>
</ul>
</li>
<li>表格：查看文档</li>
<li>表单：查看文档</li>
</ul>
<p>组件：</p>
<ul>
<li>导航条：navbar</li>
<li>分页条：pagination</li>
</ul>
<p>插件：</p>
<ul>
<li>轮播图：Carousel</li>
</ul>
<hr>
<p>Bootstrap更多用法请自询查找文档，上面很详细。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bootstrap/" rel="tag">Bootstrap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-xml" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/05/xml/"
    >XML</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/05/xml/" class="article-date">
  <time datetime="2020-05-04T16:00:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/XML/">XML</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ul>
<li><p><strong>概念：Extersible Markup Language 可扩展标记语言</strong></p>
<ul>
<li>可扩展：标签都是自定义的。</li>
</ul>
</li>
<li><p><strong>功能：</strong></p>
<ul>
<li>存储数据：<ol>
<li>配置文件</li>
<li>在网络中传输</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>与html的区别：</strong></p>
<ol>
<li>xml标签都是自定义的，html是预定义的</li>
<li>xml语法严格，html语法松散</li>
<li>xml存储数据，html展示数据</li>
</ol>
</li>
</ul>
<hr>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ol>
<li>xml第一行必须定义为文档声明</li>
<li>xml文档中有且仅有一个根标签</li>
<li>属性值必须使用引号引起来</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写</li>
</ol>
<h3 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h3><ol>
<li><p>文档声明</p>
<ol>
<li>格式<code>&lt;?xml 属性列表 ?&gt;</code></li>
<li>属性列表：<ul>
<li>version：版本号，必须的属性</li>
<li>encoding：编码格式，告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li>
<li>standalone：是否独立，是否依赖其他文件</li>
</ul>
</li>
</ol>
</li>
<li><p>指令：结合css的，了解即可。</p>
</li>
<li><p>标签：标签名称自定义的。</p>
<ul>
<li>规则：<ol>
<li>数字或者标点符号不能开头</li>
<li>名称不能以字母xml或者XML开头</li>
<li>名称中不能包含空格</li>
</ol>
</li>
</ul>
</li>
<li><p>属性：id值唯一。</p>
</li>
<li><p>文本内容：</p>
<ul>
<li><p>CDATA区：在该区域的文字会被原样展示。</p>
<pre><code>&lt;![CDATA[
    文本内容
]]&gt;</code></pre></li>
</ul>
</li>
</ol>
<h3 id="约束：规定xml文档的编写规则"><a href="#约束：规定xml文档的编写规则" class="headerlink" title="约束：规定xml文档的编写规则"></a>约束：规定xml文档的编写规则</h3><ul>
<li><p>分类：</p>
<ol>
<li>DTD：一种简单的约束技术</li>
<li>Schemea：一种复杂的约束技术</li>
</ol>
</li>
<li><p>DTD：</p>
<ul>
<li>引入dtd文档到xml文档中<ol>
<li>内部dtd：<ul>
<li><code>&lt;!DOCTYPE 根标签名 [dtd文件中具体内容]&gt;</code></li>
</ul>
</li>
<li>外部dtd：<ul>
<li>本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code></li>
<li>外部：<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;随便取个文件名&quot; &quot;dtd文件的位置URL&quot;&gt;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Schema：</p>
<ul>
<li>引入：<ol>
<li>填写xml文档的根元素</li>
<li>引入xsi前缀 xmlns:xsi=”…”</li>
<li>引入xsd文件命名空间 xsi:schemaLocation=”….”</li>
<li>为每一个xsd约束声明一个前缀，作为标识 xmlns:…=”….”</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="解析：操作xml文档，将文档中数据读取到内存中"><a href="#解析：操作xml文档，将文档中数据读取到内存中" class="headerlink" title="解析：操作xml文档，将文档中数据读取到内存中"></a>解析：操作xml文档，将文档中数据读取到内存中</h3><ul>
<li><p>操作xml文档：</p>
<ol>
<li>解析（读取）</li>
<li>写入：将内存中的数据保存到xml文档中，持久化的存储</li>
</ol>
</li>
<li><p>解析xml的方式：</p>
<ol>
<li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<ul>
<li>优点：操作方便，可以对文档进行CRUD的操作</li>
<li>缺点：占内存</li>
</ul>
</li>
<li>SAX：逐行读取，基于事件驱动的<ul>
<li>优点：不占内存</li>
<li>缺点：只能读取不能增删改</li>
</ul>
</li>
</ol>
</li>
<li><p>xml常见的解析器：</p>
<ol>
<li>JAXP：sun公司提供的解析器，支持DOM和SAX</li>
<li>DOM4J：一款非常优秀的解析器，DOM方式</li>
<li>Jsoup：是一款HTML解析器，但是比较好用，也可以用于解析XML，DOM方式</li>
<li>PULL：Andriod操作系统内置的解析器，SAX方式</li>
</ol>
</li>
</ul>
<h3 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h3><ul>
<li><p>快速入门：</p>
<ul>
<li>步骤：<ol>
<li>导入jar包</li>
<li>获取Document对象</li>
<li>获取对应的标签Element对象</li>
<li>获取数据</li>
</ol>
</li>
</ul>
</li>
<li><p>对象的使用：</p>
<ol>
<li><p>Jsoup：工具类，可以解析html文或xml文档，返回Document</p>
<ul>
<li>parse：解析html文或xml文档，返回Document对象<ul>
<li>parse(File in, String charsetName)：解析xml或html文件</li>
<li>parse(String html)：解析xml或html字符串</li>
<li>parse(URL url, int timeoustMillis)：通过网络路径获取指定的html或xml的文档对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Document：文档对象，代表内存中得到DOM树</p>
<ul>
<li>获取Element对象：<ul>
<li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li>
<li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li>
<li>getElementsByAttributeValue(String key，String value)：根据对应的属性名称和属性值获取元素对象集合</li>
<li>getElementsById(String id)：根据id属性值获取唯一Element对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Elements：元素Element对象的集合。可以当做ArrayList&lt; Element&gt;来使用</p>
</li>
<li><p>Element：元素对象</p>
<ol>
<li>获取子元素对象：<ul>
<li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li>
<li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li>
<li>getElementsByAttributeValue(String key，String value)：根据对应的属性名称和属性值获取元素对象集合</li>
<li>getElementsById(String id)：根据id属性值获取唯一Element对象</li>
</ul>
</li>
<li>获取属性值：<ul>
<li>String attr(String key)：根据属性名称获取属性值</li>
</ul>
</li>
<li>获取文本：<ul>
<li>String text()；纯文本内容</li>
<li>String html()：包括子标签的内容</li>
</ul>
</li>
</ol>
</li>
<li><p>Node：节点对象</p>
<ul>
<li>是Document和Element的父类</li>
</ul>
</li>
</ol>
</li>
<li><p>快速查询方式：</p>
<ol>
<li><p>selector：选择器</p>
<ul>
<li>使用的方法：Elements select(String cssQuery)<ul>
<li>语法：参考selector类中定义的语法</li>
</ul>
</li>
</ul>
</li>
<li><p>XPath：XML路径语言，用来确定XML文档中某部分位置的语言</p>
<ul>
<li>使用Jsoup的Xpath需要额外导入jar包</li>
<li>查询XPath语法完成查询</li>
</ul>
</li>
</ol>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XML/" rel="tag">XML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Tomcat" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/05/Tomcat/"
    >Tomcat和Servlet</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/05/Tomcat/" class="article-date">
  <time datetime="2020-05-04T16:00:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>web服务器软件。</p>
<ul>
<li>服务器：安装了服务器软件的计算机。</li>
<li>服务器软件：接收用户请求，处理请求，做出响应。</li>
<li>web服务器软件：接收用户请求，处理请求，做出响应。<ul>
<li>在web服务器软件中可以部署web项目，让用户通过浏览器访问这些项目。</li>
<li>web容器</li>
</ul>
</li>
</ul>
<p>常见的java相关的web服务器软件：</p>
<ul>
<li>webLogic：Oracle公司，大型javaEE服务器，支持所有的javaEE规范，收费。</li>
<li>webSphere：IBM公司，大型javaEE服务器，支持所有的javaEE规范，收费。</li>
<li>JBOSS：JBOSS公司，大型javaEE服务器，支持所有的javaEE规范，收费。</li>
<li>Tomcat：Apache基金组织，中小型javaEE服务器，仅仅支持少量javaEE规范，开源免费。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>部署项目的方式：<ol>
<li>直接将项目放在webapps文件夹下。<ul>
<li>简化部署：将项目打包成一个war包，再将war包放到webapps目录下，war包会自动解压缩。</li>
</ul>
</li>
<li>配置conf/server.xml文件，在&lt; host&gt;标签体中配置<code>&lt;Context docBase=&quot;项目存放路径&quot; path=&quot;/虚拟目录&quot; /&gt;</code></li>
<li>在conf/Catalina/localhost创建任意名称的xml文件，在文件中编写<code>&lt;Context docBase=&quot;项目存放路径&quot; /&gt;</code>，虚拟目录就是xml文件的名称。</li>
</ol>
</li>
</ul>
<h1 id="Servlet简单学习"><a href="#Servlet简单学习" class="headerlink" title="Servlet简单学习"></a>Servlet简单学习</h1><p>运行在服务器端的小程序。</p>
<ul>
<li>Servlet就是一个接口，定义了java类被浏览器访问到(tomcat识别)的规则。</li>
<li>将来我们自定义一个类，实现Servlet接口，复写方法。</li>
</ul>
<h2 id="Servlet快速入门"><a href="#Servlet快速入门" class="headerlink" title="Servlet快速入门"></a>Servlet快速入门</h2><ol>
<li><p>创建javaEE的项目</p>
</li>
<li><p>定义一个类，必须实现Servlet接口</p>
</li>
<li><p>实现接口中的抽象方法</p>
</li>
<li><p>配置Servlet</p>
<ul>
<li><p>web.xml中配置：</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;
    &lt;servlet-class&gt;web.servlet.ServletDemo01&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre></li>
</ul>
</li>
</ol>
<h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><ol>
<li>当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的servlet的资源路径。</li>
<li>查找web.xml文件是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</li>
<li>如果有则在找到对应的<code>&lt;servlet-class&gt;</code>全类名。</li>
<li>tomcat会将字节码文件加载进内存，并且创建其对象。</li>
<li>调用其方法。</li>
</ol>
<h2 id="ervlet的生命周期："><a href="#ervlet的生命周期：" class="headerlink" title="ervlet的生命周期："></a>ervlet的生命周期：</h2><ol>
<li><p>被创建：执行init方法，只执行一次。</p>
<ul>
<li><p>servlet什么时候被创建？</p>
<ul>
<li>默认情况下，第一次访问时，servlet被创建</li>
<li>可以配置执行servlet的创建时机<ul>
<li>在<code>&lt;servlet&gt;</code>标签下配置<ol>
<li>第一次被访问时，创建<ul>
<li><code>&lt;load-on-startup&gt;</code>的值为负数</li>
</ul>
</li>
<li>在服务器启动时，创建<ul>
<li><code>&lt;load-on-startup&gt;</code>的值为0或正数</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>servlet的init方法只执行一次，说明一个servlet在内存中只存在一个对象，servlet是单例的。</p>
<ul>
<li>多个用户同时访问时，可能存在线程安全问题。<ul>
<li>解决：尽量不要在servlet中定义成员变量。即使定义了成员变量，也不要对其修改值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>提供服务：执行service方法，可以执行多次。</p>
<ul>
<li>每次访问servlet时都会执行一次。</li>
</ul>
</li>
<li><p>被销毁：执行destroy方法，只执行一次。</p>
<ul>
<li>servlet被销毁时执行一次，服务器正常关闭时。</li>
</ul>
</li>
</ol>
<h2 id="Servlet3-0及以上："><a href="#Servlet3-0及以上：" class="headerlink" title="Servlet3.0及以上："></a>Servlet3.0及以上：</h2><ul>
<li>好处：<ul>
<li>支持注解配置。可以不需要web.xml。</li>
</ul>
</li>
<li>步骤：<ol>
<li>创建javaEE项目，选择servlet版本3.0以上，可以不创建web.xml。</li>
<li>定义一个类实现Servlet接口。</li>
<li>复写方法。<ol start="4">
<li>在类上使用@WebServlet(“资源路径”)注解进行配置。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Servlet的体系结构："><a href="#Servlet的体系结构：" class="headerlink" title="Servlet的体系结构："></a>Servlet的体系结构：</h2><ul>
<li>Servlet，GenericServlet，HttpServlet<ol>
<li>GenericServlet继承自Servlet，将Servlet接口中除service方法都进行了默认空实现，只将service方法作为抽象方法，定义时只需实现service方法即可。</li>
<li>HttpServlet继承自GenericServlet，是对http协议的一种封装，简化操作。定义时可以复写doGet/doPost方法。</li>
</ol>
</li>
</ul>
<h2 id="Servlet相关配置："><a href="#Servlet相关配置：" class="headerlink" title="Servlet相关配置："></a>Servlet相关配置：</h2><ol>
<li>urlpartten：Servlet访问路径<ol>
<li>一个Servlet可以定义多个访问路径：@WebServlet({“/路径1”，”/路径2”，”/路径3”})。</li>
<li>路径定义规则：<ol>
<li>/xxx</li>
<li>/xxxx/xx/xxx：多层路径，目录结构。</li>
<li>*.后缀名</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="IDEA与Tomcat的相关配置"><a href="#IDEA与Tomcat的相关配置" class="headerlink" title="IDEA与Tomcat的相关配置"></a>IDEA与Tomcat的相关配置</h1><ol>
<li><p>IDEA会为每一个Tomacat部署的项目单独建立一份配置文件。</p>
<ul>
<li>查看控制台的log中的CATALINA_BASE。</li>
</ul>
</li>
<li><p>工作空间项目和Tomacat部署的web项目是两个存在。</p>
<ul>
<li>Tomcat真正访问的是“Tomacat部署的web项目”，“Tomacat部署的web项目”对应着的是“工作空间项目”的web目录下的所有资源。</li>
<li>WEB-INF目录下的资源不能被浏览器直接访问。</li>
<li>断点调试：使用Debug启动而不是Run。</li>
</ul>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-JavaScript" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/01/JavaScript/"
    >JavaScript</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/01/JavaScript/" class="article-date">
  <time datetime="2020-04-30T16:00:00.000Z" itemprop="datePublished">2020-05-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="ECMAScript：客户端脚本语言的标准"><a href="#ECMAScript：客户端脚本语言的标准" class="headerlink" title="ECMAScript：客户端脚本语言的标准"></a>ECMAScript：客户端脚本语言的标准</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><ol>
<li>与html结合方式<ol>
<li>内部js：定义&lt; script&gt;js代码&lt; script/&gt;</li>
<li>外部js：定义&lt; script src属性引入外部js文件&gt;js代码&lt; script/&gt;</li>
</ol>
<ul>
<li><strong>注意：&lt; script&gt;可以定义在html页面的任何地方，但是定义的位置会影响执行的顺序。&lt; script&gt;标签可以定义多个。</strong></li>
</ul>
</li>
<li>注释<ul>
<li>和java中注释规则一样。</li>
</ul>
</li>
<li>数据类型<ol>
<li>原始数据类型：<ol>
<li>number：数字。整数/小数/NaN（not a number 一个不是数字的数字类型）</li>
<li>string：字符串</li>
<li>boolean：true/false</li>
<li>null：空</li>
<li>undefined：未定义。如果一个对象没有给初始化值，则会被默认赋值为undefined</li>
</ol>
</li>
<li>引用数据类型：对象</li>
</ol>
</li>
<li>变量<ul>
<li>Java是强类型语言，而JavaScript是弱类型语言。<ul>
<li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型，只能存储固定的数据类型。</li>
<li>弱类型：在开辟变量存储空间时，不定义空间将来存储的数据的数据类型，可以存放任意的数据类型。</li>
</ul>
</li>
<li>语法：var 变量名=变量值；</li>
</ul>
</li>
<li>运算符<ul>
<li>一元运算符：只有一个运算数的运算符<ul>
<li>++，–，+（正号），-（负号），等</li>
<li><strong>注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。</strong><ul>
<li><strong>其他类型转number：</strong><ul>
<li><strong>string转number，按照字面值转换，如果字面值不是数字，则转为NaN（不是数字的数字）</strong></li>
<li><strong>boolean转number，true转为1，false转为0</strong></li>
<li><strong>其他两种类型转为NaN</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>算数运算符：数学运算<ul>
<li>+，-，*，/，%等</li>
</ul>
</li>
<li>赋值运算符<ul>
<li>=，+=，-=等</li>
</ul>
</li>
<li>比较运算符<ul>
<li>&lt;，&gt;，&gt;=，&lt;=，==，===（全等于）</li>
<li>比较方式：<ol>
<li>类型相同：直接比较。</li>
<li>类型不同：先进行类型转换再进行比较。</li>
</ol>
</li>
<li>===（全等于）：在比较之前，先判断类型，如果类型不一样，则直接返回false。</li>
</ul>
</li>
<li>逻辑运算符<ul>
<li>&amp;&amp;，||，！</li>
<li>其他类型转为boolean类型：<ul>
<li>number：0或NaN为false，其他都是true</li>
<li>string：除了空字符串（“”），其他都是true</li>
<li>null与undefined：都是false</li>
<li>对象：所有对象都为true</li>
</ul>
</li>
</ul>
</li>
<li>三元运算符<ul>
<li>?:表达式</li>
</ul>
</li>
</ul>
</li>
<li>流程控制语句<ul>
<li>if…else…</li>
<li>switch<ul>
<li>在JS中，switch可以接收任意原始数据类型</li>
</ul>
</li>
<li>while</li>
<li>do…while</li>
<li>for</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-基本对象"><a href="#2-基本对象" class="headerlink" title="2.基本对象"></a>2.基本对象</h3><ul>
<li>Function：函数对象<ol>
<li>创建<ol>
<li><code>var fun = new Function(形参列表，方法体)</code></li>
<li><code>function 方法名称(形参列表){方法体}</code></li>
<li><code>var 方法名 = function(形参列表){方法体}</code></li>
</ol>
</li>
<li>方法</li>
<li>属性<ul>
<li>length：代表形参的个数</li>
</ul>
</li>
<li>特点<ol>
<li>方法定义时，形参的类型可以不用写，返回值类型也bu’xie</li>
<li>方法是一个对象，如果定义一个名称相同的方法，会覆盖之前的方法</li>
<li>在JS中，方法的调用只与方法的名称有关，和参数列表无关</li>
<li>在方法声明中有一个隐藏的内置对象（数组），arguments，封装所有的实际参数</li>
</ol>
</li>
<li>调用：<ul>
<li>方法名称(参数列表)；</li>
</ul>
</li>
</ol>
</li>
<li>Array：数组对象<ol>
<li>创建<ol>
<li><code>var arr = new Array(元素列表)；</code></li>
<li><code>var arr = new Array(数组长度)；</code></li>
<li><code>var arr = [元素列表]；</code></li>
</ol>
</li>
<li>方法<ul>
<li>join(参数)：将数组的元素按照指定的分隔符拼接为字符串</li>
<li>push()：向数组中的末尾添加一个元素，并返回新的长度</li>
</ul>
</li>
<li>属性<ul>
<li>length：数组的长度</li>
</ul>
</li>
<li>特点<ol>
<li>JS中，数组元素的类型是可变的</li>
<li>JS中，数组的长度是可变的</li>
</ol>
</li>
</ol>
</li>
<li>Boolean</li>
<li>Date<ol>
<li>创建<ol>
<li><code>var date = new Date()；</code></li>
</ol>
</li>
<li>方法<ul>
<li>toLocalString()：返回本地时间字符串格式</li>
<li>getTime()：获取毫秒值，返回当前日期对象描述的时间到970年1月1日0点的差</li>
</ul>
</li>
<li>属性</li>
<li>特点</li>
</ol>
</li>
<li>Math<ol>
<li>创建<ul>
<li>不用创建，直接使用</li>
</ul>
</li>
<li>方法<ul>
<li>random()：返回0到1之间的随机数，包含0不包含1</li>
<li>cell(x)：向上取整</li>
<li>floor(x)：向下取整</li>
<li>round(x)：四舍五入</li>
</ul>
</li>
<li>属性<ul>
<li>PI：圆周率</li>
</ul>
</li>
<li>特点</li>
</ol>
</li>
<li>Number</li>
<li>String</li>
<li>RegExp：正则表达式对象<ul>
<li>正则表达式：定义字符串的组成规则<ol>
<li>单个字符：[]</li>
</ol>
<ul>
<li>如：[a] [ab] [a-zA-Z0-9_]</li>
<li>特殊符号代表特殊含义的单个字符：<ul>
<li>\d：单个数字字符 [0-9]</li>
<li>\w：单个单词字符 [a-zA-Z0-9_]</li>
</ul>
</li>
</ul>
<ol start="2">
<li>量词符号：<ul>
<li>?：表示出现0次或1次</li>
<li>*：表示出现0次或多次</li>
<li>+：表示出现1次或多次</li>
<li>{m,n}：表示出现次数在m与n之中，包括m和n<ul>
<li>{m,}：至少出现m次</li>
<li>{,n}：至多出现n次</li>
</ul>
</li>
</ul>
</li>
<li>开始结束符号：<ul>
<li>^：开始</li>
<li>$：结束</li>
</ul>
</li>
</ol>
</li>
<li>正则对象<ol>
<li>创建<ul>
<li><code>var reg = new RegExp(&quot;正则表达式&quot;)；</code><ul>
<li><strong>注意：正则表达式中的\应该写两个，因为在双引号中会被转义</strong></li>
</ul>
</li>
<li><code>var reg = /正则表达式/；</code></li>
</ul>
</li>
<li>方法<ul>
<li>test(参数)：验证指定的字符串是否符合正则表达式</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>Global<ol>
<li>特点：全局对象，这个Global对象中封装的方法可以不需要对象就直接调用。 方法名();</li>
<li>方法：<ul>
<li>encodeURI()：url编码</li>
<li>decodeURI()：url解码</li>
<li>encodeURIComponent()：url编码，会进行编码的字符更多</li>
<li>decodeURIComponent()：url解码</li>
<li>parseInt()：将字符串转为数字<ul>
<li>逐一判断每个字符是不是是否是数字，直到不是数字为止，将前变数字部分转换为number</li>
</ul>
</li>
<li>isNaN()：判断一个字符是不是NaN</li>
<li>eval()：将JavaScript字符串，转成脚本来执行</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-BOM对象"><a href="#3-BOM对象" class="headerlink" title="3.BOM对象"></a>3.BOM对象</h3><ul>
<li><p>概念：Browser object Model 浏览器对象模型</p>
<ul>
<li>将浏览器的各个组成部分封装成对象。</li>
</ul>
</li>
<li><p>组成：</p>
<ol>
<li>Window：窗口对象<ul>
<li>创建</li>
<li>方法：<ol>
<li>与弹出框有关的方法<ul>
<li>alert()：显示带有一段消息和一个确认按钮的警告框。</li>
<li>confirm()：显示带有一段信息以及确认按钮和取消按钮的对话框。<ul>
<li>用户点击确认按钮，则返回true</li>
<li>用户点击取消按钮，则返回false</li>
</ul>
</li>
<li>prompt()：显示可提示用户输入的对话框。<ul>
<li>返回值。获取用户输入的值。</li>
</ul>
</li>
</ul>
</li>
<li>与打开关闭有关的方法：<ul>
<li>open()：打开一个新的浏览器窗口</li>
<li>close()：关闭浏览器窗口</li>
</ul>
</li>
<li>与定时器有关的方法<ul>
<li>setTimeout()：在指定的毫秒数后调用函数或计算表达式。<ul>
<li>参数：<ul>
<li>参数1：js代码或者方法对象</li>
<li>参数2：毫秒值</li>
</ul>
</li>
<li>返回值：唯一标识</li>
</ul>
</li>
<li>clearTimeout()：取消由setTimeout()方法设置的timeout。</li>
<li>setInterval()：按照指定的周期（以毫秒计）来调用函数或表达式。<ul>
<li>参数：<ul>
<li>参数1：js代码或者方法对象</li>
<li>参数2：毫秒值</li>
</ul>
</li>
<li>返回值：唯一标识</li>
</ul>
</li>
<li>clearInterval()：取消seItnterval()设置的timeout。</li>
</ul>
</li>
</ol>
</li>
<li>属性<ul>
<li>获取其他BOM对象：<ul>
<li>history</li>
<li>location</li>
<li>Navigator</li>
<li>Screen</li>
</ul>
</li>
<li>获取DOM对象<ul>
<li>document</li>
</ul>
</li>
</ul>
</li>
<li>特点：<ol>
<li>不需要创建，可以直接使用window使用。window.方法名()；</li>
<li>window引用可以省略。方法名()；</li>
</ol>
</li>
</ul>
</li>
<li>Navigator：浏览器对象</li>
<li>Screen：显示器屏幕对象</li>
<li>History：历史记录对象<ul>
<li>创建(获取)<ol>
<li>window.history</li>
<li>history</li>
</ol>
</li>
<li>方法<ul>
<li>back() 加载history列表中的前一个URL</li>
<li>forward() 加载history列表中的下一个URL</li>
<li>go() 加载history列表中的某个具体页面<ul>
<li>参数：<ul>
<li>正数：前进几个历史记录</li>
<li>负数：后退几个历史记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>属性<ul>
<li>length：返回当前窗口历史记录列表中的URL数量</li>
</ul>
</li>
</ul>
</li>
<li>Location：地址栏对象<ol>
<li>创建(获取)<ul>
<li>window.location</li>
<li>location</li>
</ul>
</li>
<li>方法<ul>
<li>reload() 重新加载当前文档。刷新</li>
</ul>
</li>
<li>属性<ul>
<li>href 设置或返回完整的URL</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-DOM对象"><a href="#4-DOM对象" class="headerlink" title="4.DOM对象"></a>4.DOM对象</h3><ul>
<li><p>概念：Document Object Model 文档对象模型</p>
<ul>
<li>将标记语言文档的各个组成部分封装为对象。可以使用这些个对象，对标记语言文档进行CRUD的动态操作。</li>
</ul>
</li>
<li><p>功能：控制html文档的内容</p>
</li>
<li><p>W3C DOM标准被分为3个不同的部分</p>
<ul>
<li>核心DOM：针对任何结构化文档的标准模型<ul>
<li>Document对象：文档对象</li>
<li>Element：元素对象</li>
<li>Attribute：属性对象</li>
<li>Text：文本对象</li>
<li>Comment：注释对象</li>
<li>Node：节点对象，其他五个的父对象</li>
</ul>
</li>
<li>XML DOM：针对XML文档的标准模型</li>
<li>HTML DOM：针对HTML文档的标准模型</li>
</ul>
</li>
<li><p>核心DOM模型：</p>
<ul>
<li>Document对象：文档对象<ol>
<li>创建(获取)：在htnl模型中可以使用window对象来获取<ol>
<li>window.document</li>
<li>document</li>
</ol>
</li>
<li>方法：<ul>
<li>获取Element对象：<ul>
<li>getElementById() 根据id属性值获取元素对象。</li>
<li>getElementsByTagName() 根据元素名称获取元素对象们，返回值是一个数组</li>
<li>getElementsByClassName() 根据class的属性值来获取元素对象们</li>
<li>getElementsByName() 根据Name属性值获取元素对象们</li>
</ul>
</li>
<li>创建其他DOM对象：<ul>
<li>createAttribute(Name)</li>
<li>createComment()</li>
<li>createElement()</li>
<li>createTextNode()</li>
</ul>
</li>
</ul>
</li>
<li>属性：<ul>
<li>parentNode：获取父节点</li>
</ul>
</li>
</ol>
</li>
<li>Element：元素对象<ol>
<li>获取：通过Document对象来获取和创建</li>
<li>方法：<ul>
<li>removeAttribute()：删除属性</li>
<li>setAttribute()：设置属性</li>
</ul>
</li>
</ol>
</li>
<li>Node：节点对象，其他五个的父对象<ul>
<li>特点：所有DOM对象都可以被认为是一个节点</li>
<li>方法：<ul>
<li>COUR DOM树：<ul>
<li>appendChild()：向节点的子节点列表的结尾添加新的子节点。</li>
<li>removeChild()：删除(并返回)当前节点的指定子节点。</li>
<li>replaceChild()：用新的节点替换一个子节点</li>
</ul>
</li>
</ul>
</li>
<li>属性：</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>HTML DOM</li>
</ul>
<ol>
<li><p>标签体的设置和获取：innerHTML</p>
</li>
<li><p>使用html元素对象的属性：查询API文档</p>
</li>
<li><p>控制元素样式：</p>
<ol>
<li>使用元素的style属性来设置</li>
<li>提前定义好类选择器的样式，通过元素的className属性来设置类属性值。</li>
</ol>
</li>
</ol>
<ul>
<li><p>操作Element对象</p>
<ol>
<li>修改属性值<ol>
<li>明确获取的对象是哪一个？</li>
<li>查看API文档，看其中有哪些属性值可以设置</li>
</ol>
</li>
<li>修改标签体内容<ul>
<li>属性：innerHTML</li>
</ul>
</li>
</ol>
</li>
<li><p>事件简单学习</p>
<ul>
<li>功能：某些组件被执行了某些操作后触发某些代码的执行</li>
<li>如何绑定事件：<ol>
<li>直接在html标签上，指定事件的属性，属性值就是js代码</li>
<li>通过js获取元素对象，指定事件属性</li>
</ol>
</li>
</ul>
</li>
<li><p>事件</p>
<ul>
<li>常见的事件：<ol>
<li>点击事件：<ol>
<li>onclick：当用户点击某个对象时调用的事件句柄。</li>
<li>ondblclick：双击事件</li>
</ol>
</li>
<li>焦点事件：<ol>
<li>onblur：失去焦点<ul>
<li>可以用于表单验证</li>
</ul>
</li>
<li>onfocus：元素获得焦点</li>
</ol>
</li>
<li>加载事件：<ol>
<li>onload：一张页面或一张图片完成加载</li>
</ol>
</li>
<li>鼠标事件：<ol>
<li>onmousedown：鼠标按钮被按下<ul>
<li>定义方法时，定义一个形参，接受event对象</li>
<li>event对象的button属性可以获取哪个鼠标按钮键被点击了</li>
</ul>
</li>
<li>onmouseup：鼠标按键被松开</li>
<li>onmousemove：鼠标被移动</li>
<li>onmouseover：鼠标移到某元素之上</li>
<li>onmouseout：鼠标从某元素移开</li>
</ol>
</li>
<li>键盘事件：<ol>
<li>onkeydown：键盘某个按键被按下</li>
<li>onkeyup：键盘某个按键被松开</li>
<li>onkeypress：键盘按下并松开</li>
</ol>
</li>
<li>选中和改变：<ol>
<li>onchange：域的内容被改变</li>
<li>onselect：文本被选中</li>
</ol>
</li>
<li>表单事件：<ol>
<li>onsubmit：确认按钮被点击<ul>
<li>可以阻止表单的提交，方法返回true则提交，返回false则不提交</li>
</ul>
</li>
<li>onreset：重置按钮被点击</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-CSS" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/01/CSS/"
    >CSS</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/01/CSS/" class="article-date">
  <time datetime="2020-04-30T16:00:00.000Z" itemprop="datePublished">2020-05-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>页面美化和布局控制</p>
<ul>
<li><p>概念：Cascading Style Sheets 层叠样式表</p>
<ul>
<li>层叠：多个样式可以作用在同一个html的元素上，同时生效</li>
</ul>
</li>
<li><p>好处</p>
<ol>
<li>功能强大</li>
<li>将内容的展示和样式控制分离<ul>
<li>降低耦合度</li>
<li>让分工协作更容易</li>
<li>提高开发效率</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="CSS的使用：CSS与html结合方式"><a href="#CSS的使用：CSS与html结合方式" class="headerlink" title="CSS的使用：CSS与html结合方式"></a>CSS的使用：CSS与html结合方式</h2><ol>
<li><p>内联样式：在标签内使用style属性指定css代码</p>
<ul>
<li>如：&lt; div style=”color:red;”&gt;hello&lt; /div&gt;</li>
</ul>
</li>
<li><p>内部样式：在head标签内，定义style标签，style标签的内容就是css代码</p>
<ul>
<li><p>如</p>
<pre><code>&lt;head&gt;
    &lt;style&gt;
        div{
            color:blue;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;div&gt;hello&lt;/div&gt;</code></pre></li>
</ul>
</li>
<li><p>外部样式:定义css资源文件，在head标签内，定义link标签，引入外部资源文件。</p>
</li>
</ol>
<ul>
<li><p>如</p>
<pre><code>&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;
&lt;/head&gt;

&lt;div&gt;hello&lt;/div&gt;</code></pre></li>
</ul>
<h2 id="CSS基本语法"><a href="#CSS基本语法" class="headerlink" title="CSS基本语法"></a>CSS基本语法</h2><ul>
<li><p>格式：</p>
<pre><code>选择器{
    属性名1：属性值1；
    属性名2：属性值2；
    .....
}</code></pre></li>
<li><p>选择器：筛选具有相似特征的元素</p>
</li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul>
<li><p>分类：</p>
<ol>
<li><p>基础选择器</p>
<ol>
<li>id选择器：选择具体的id属性值的元素。<ul>
<li>语法：#id属性值{}</li>
<li><strong>优先级最高</strong></li>
</ul>
</li>
<li>元素选择器：选择具有相同标签名称的元素。<ul>
<li>语法：标签名称{}</li>
<li><strong>优先级低于id选择器和类选择器</strong></li>
</ul>
</li>
<li>类选择器：选择具有相同的class属性值的元素。<ul>
<li>语法：.class属性值{}</li>
<li><strong>优先级低于id选择器</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>扩展选择器</p>
<ol>
<li>*：表示选择所有元素<ul>
<li>语法：*{}</li>
</ul>
</li>
<li>并集选择器：筛选选择器1下和选择器2共有的元素<ul>
<li>语法：选择器1，选择器2{}</li>
</ul>
</li>
<li>子选择器：筛选选择器1下的选择器2的元素<ul>
<li>语法：选择器1 选择器2{}</li>
</ul>
</li>
<li>父选择器：：筛选选择器2的父元素选择器1<ul>
<li>语法：选择器1&gt;选择器2{}</li>
</ul>
</li>
<li>属性选择器：选择元素名称，属性名=属性值的元素<ul>
<li>语法：元素名称[ 属性名=”属性值” ]{}</li>
</ul>
</li>
<li>伪类选择器：选择一些元素所具有的状态<ul>
<li>语法：元素:状态{}</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li><p>字体、文本</p>
<ul>
<li>font-size：字体大小</li>
<li>color：文本颜色</li>
<li>text-align：文本对齐方式</li>
<li>line-height：行高</li>
</ul>
</li>
<li><p>背景</p>
<ul>
<li>background：复合属性。</li>
</ul>
</li>
<li><p>边框</p>
<ul>
<li>border：设置边框，复合属性。</li>
</ul>
</li>
<li><p>尺寸</p>
<ul>
<li>width：宽度</li>
<li>height：高度</li>
</ul>
</li>
<li><p>盒子模型：控制布局</p>
<ul>
<li>margin：外边距</li>
<li>padding：内边距<ul>
<li>默认情况下内边距会影响整个盒子的大小，可以使用box-sizing：boder-box，让width和height就是盒子最终大小。</li>
</ul>
</li>
<li>float：浮动</li>
</ul>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-ConnPool" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/28/ConnPool/"
    >数据库连接池</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/28/ConnPool/" class="article-date">
  <time datetime="2020-04-27T16:00:00.000Z" itemprop="datePublished">2020-04-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><ul>
<li><p><strong>概念：</strong> 其实就是一个容器（集合），存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
</li>
<li><p><strong>好处：</strong> </p>
<ol>
<li>节约资源</li>
<li>用户访问高效</li>
</ol>
</li>
<li><p><strong>实现：</strong></p>
<ol>
<li><p>标准接口：DataSource</p>
<ol>
<li>方法：<ul>
<li>获取连接：getConnection()</li>
<li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了，而是归还连接。</li>
</ul>
</li>
</ol>
</li>
<li><p>一般我们不去实现它，有数据库厂商来实现</p>
<ol>
<li>C3P0：数据库连接池技术。</li>
<li>Druid：数据库连接池技术，由阿里巴巴提供。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="C3P0：数据库连接池技术"><a href="#C3P0：数据库连接池技术" class="headerlink" title="C3P0：数据库连接池技术"></a>C3P0：数据库连接池技术</h2><ul>
<li>步骤：<ol>
<li>导入jar包（两个） c3p0-0.9.5.5-sources.jar和mchange-commons-java-0.2.19-sources.jar</li>
<li>定义配置文件：<ul>
<li>名称：c3p0.properties或者c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可</li>
</ul>
</li>
<li>创建核心对象：数据库连接池对象 ComboPooledDataSource</li>
<li>获取连接：getConnection</li>
</ol>
</li>
</ul>
<h2 id="Druid：数据库连接池技术，由阿里巴巴提供"><a href="#Druid：数据库连接池技术，由阿里巴巴提供" class="headerlink" title="Druid：数据库连接池技术，由阿里巴巴提供"></a>Druid：数据库连接池技术，由阿里巴巴提供</h2><ul>
<li><p>步骤：</p>
<ol>
<li>导入jar包 druid-1.1.22.jar</li>
<li>定义配置文件：<ul>
<li>是properties形式的</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>获取数据库连接池对象：加载配置文件，然后通过工厂来获取 DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
</li>
<li><p>定义工具类</p>
<ol>
<li>定义一个类 JDBCUtils</li>
<li>提供静态代码块加载配置文件，初始化连接池对象</li>
<li>提供方法：<ol>
<li>获取连接方法：通过数据库连接池获取连接</li>
<li>释放资源</li>
<li>获取连接池对象的方法</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>代码实现示例</strong></p>
<pre><code>    public class JDBCUtils {

    private static DataSource ds;

    //数据库连接池的初始化
    static {
        try {
            Properties prop = new Properties();
            prop.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
            ds = DruidDataSourceFactory.createDataSource(prop);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //获取连接的方法
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }

    //释放资源的方法
    public static void close(Connection conn, Statement st, ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
        if (st != null) {
            try {
                st.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }

    //释放资源的方法
    public static void close(Connection conn, Statement st) {
        close(conn, st, null);
    }

    //获取连接池对象的方法
    public static DataSource getDataSource() {
        return ds;
    }

}</code></pre></li>
</ul>
<h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><ul>
<li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发。</p>
</li>
<li><p>步骤：</p>
<ol>
<li>导入jar包。</li>
<li>创建JDBCTemplate对象。依赖于数据源DataSource。</li>
<li>调用DBCTemplate来完成增删改查的操作。<ul>
<li>update()：执行DML语句。</li>
<li>queryForMap()：查询结果将结果集封装为Map集合，将一条记录封装为Map集合。<ul>
<li>注意：这个方法查询的结果集长度只能是1。</li>
</ul>
</li>
<li>queryForList()：查询结果将结果集封装为List集合。<ul>
<li>注意：将每一条记录封装为Map集合，再将map集合装载到List集合中。</li>
</ul>
</li>
<li>query()：查询结果将结果封装为JavaBean对象。<ul>
<li>参数：RowMapper<ul>
<li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li>
<li>new BeanPropertyRowMapper&lt;类型&gt;（类型.class）</li>
</ul>
</li>
</ul>
</li>
<li>queryForObject()：查询结果将结果封装为对象。<ul>
<li>一般用于聚合函数的查询。</li>
<li>queryForObject(sql语句, 返回值类型.class);</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-HTML" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/28/HTML/"
    >HTML</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/28/HTML/" class="article-date">
  <time datetime="2020-04-27T16:00:00.000Z" itemprop="datePublished">2020-04-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTML/">HTML</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul>
<li>概念：是最基础的网页开发语言<ul>
<li>Hyper Text Markup Language 超文本标记语言<ul>
<li>超文本：超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。</li>
<li>标记语言：由标签构成的语言。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="几类标签的学习"><a href="#几类标签的学习" class="headerlink" title="几类标签的学习"></a>几类标签的学习</h2><h3 id="1-文件标签：构成html最基本的标签"><a href="#1-文件标签：构成html最基本的标签" class="headerlink" title="1.文件标签：构成html最基本的标签"></a>1.文件标签：构成html最基本的标签</h3><ul>
<li>htlm：html文档的根标签。</li>
<li>head：头标签。用于指定html文档的一些属性。引入外部的资源。</li>
<li>title：标题标签。</li>
<li>body：体标签。</li>
<li>&lt; !DOCTYPE html &gt; ：html5中定义该文档是html文档。</li>
</ul>
<h3 id="2-文本标签：和文本有关的标签"><a href="#2-文本标签：和文本有关的标签" class="headerlink" title="2.文本标签：和文本有关的标签"></a>2.文本标签：和文本有关的标签</h3><ul>
<li><p>注释：&lt; !–注释内容–&gt;</p>
</li>
<li><p>&lt; h1&gt; to &lt; h6&gt;：标题标签</p>
</li>
<li><p>&lt; p&gt;：段落标签</p>
</li>
<li><p>&lt; br&gt;：换行</p>
</li>
<li><p>&lt; hr&gt;：显示一条水平线</p>
</li>
<li><p>&lt; b&gt;：粗体</p>
</li>
<li><p>&lt; i&gt;：斜体</p>
</li>
<li><p>&lt; center&gt;：文本居中</p>
</li>
<li><p>&lt; font&gt;：字体标签(HTML5不再支持)</p>
<ul>
<li>color：颜色</li>
<li>size：大小</li>
<li>face：字体</li>
</ul>
</li>
<li><p>属性定义：(HTML5中也推荐不再支持)</p>
<ul>
<li>color：<ol>
<li>英文单词定义</li>
<li>rgb(值1，值2，值3)</li>
<li>#值1值2值3，值为十六进制</li>
</ol>
</li>
<li>width：<ol>
<li>数值：width=’20’，数值单位默认是px(像素)</li>
<li>%数值：表示相对于父元素的占比</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-图片标签"><a href="#3-图片标签" class="headerlink" title="3.图片标签"></a>3.图片标签</h3><ul>
<li>&lt; img&gt;：展示一张图片<ul>
<li>以./开头的路径表示以当前目录开始</li>
<li>以../开头的路径表示退回上一层路径</li>
</ul>
</li>
</ul>
<h3 id="4-列表标签"><a href="#4-列表标签" class="headerlink" title="4.列表标签"></a>4.列表标签</h3><ul>
<li>有序列表<ul>
<li>&lt; ol&gt;</li>
<li>&lt; li&gt;</li>
</ul>
</li>
<li>无序列表<ul>
<li>&lt; ul&gt;</li>
<li>&lt; li&gt;</li>
</ul>
</li>
</ul>
<h3 id="5-链接标签"><a href="#5-链接标签" class="headerlink" title="5.链接标签"></a>5.链接标签</h3><ul>
<li>&lt; a&gt;：定义一个超链接<ul>
<li>属性：<ul>
<li>href：指定访问资源的URL</li>
<li>target：<ul>
<li>_blank    在新窗口中打开被链接文档。</li>
<li>_self    默认。在相同的框架中打开被链接文档。</li>
<li>_parent    在父框架集中打开被链接文档。</li>
<li>_top    在整个窗口中打开被链接文档。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-表格标签"><a href="#6-表格标签" class="headerlink" title="6.表格标签"></a>6.表格标签</h3><ul>
<li>&lt; table&gt;：定义表格<ul>
<li>width：宽度</li>
<li>border：边框</li>
<li>cellpadding：定义内容和单元格的距离。</li>
<li>cellspacing：定义单元格之间的距离，如果为0，则边框线合为一体只有一条。</li>
<li>bgcolor：背景色</li>
</ul>
</li>
<li>&lt; td&gt;：定义单元格<ul>
<li>colspan：合并列</li>
<li>rowspan：合并行</li>
</ul>
</li>
<li>&lt; tr&gt;：定义行</li>
<li>&lt; th&gt;：定义表头单元格</li>
<li>&lt; caption&gt;：表格标题</li>
<li>&lt; thead&gt;：表示表格的头部分</li>
<li>&lt; tbody&gt;：表示表格的体部分</li>
<li>&lt; tfoot&gt;：表示表格的脚部分</li>
</ul>
<h3 id="7-div和span标签"><a href="#7-div和span标签" class="headerlink" title="7.div和span标签"></a>7.div和span标签</h3><ul>
<li>&lt; span&gt;:文本信息在一行展示，行内标签，内联标签。</li>
<li>&lt; div&gt;:每一个div占满一整行。块级标签。</li>
</ul>
<h3 id="8-语义化标签"><a href="#8-语义化标签" class="headerlink" title="8.语义化标签"></a>8.语义化标签</h3><p>html5中为了提高程序的可读性，提供了一些标签。</p>
<ul>
<li>&lt; header&gt;</li>
<li>&lt; footer&gt;</li>
<li>……</li>
</ul>
<h3 id="9-表单标签"><a href="#9-表单标签" class="headerlink" title="9.表单标签"></a>9.表单标签</h3><ul>
<li><p>表单：用于采集用户输入的数据的。用于和服务器进行交互。</p>
</li>
<li><p>&lt; form&gt;：表单标签</p>
<ul>
<li><p>属性：</p>
<ul>
<li>action：指定提交数据的URL</li>
<li>method：指定提交方式<ul>
<li>分类：一共七种，常用的有两种<ul>
<li>get：请求参数会在地址栏中显示。请求参数的长度有限制。不太安全。</li>
<li>post：请求参数不会在地址栏中显示。会封装在请求体中。请求参数长度没有限制。较为安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表单项中的数据想要被提交，必须指定其name属性</p>
</li>
</ul>
</li>
<li><p>表单项标签</p>
<ul>
<li><p>&lt; input&gt;：可以通过type属性值，改变元素展示的样子</p>
<ul>
<li><p>type属性：</p>
<ul>
<li>text；文本输入框(默认值)<ul>
<li>placeholder：指定输入框的提示信息，当有输入时，清空提示信息。</li>
</ul>
</li>
<li>password：密码输入框</li>
<li>radio：单选框<ul>
<li><strong>注意：</strong><ol>
<li>让多个单选框实现单选的效果，则多个单选框的name值必须一样。</li>
<li>一般会给每一个单选框提供value值，指定其被选中后提交的值。</li>
<li>checked属性可以指定默认选中的值。</li>
</ol>
</li>
</ul>
</li>
<li>checkbox：复选框<ul>
<li><strong>注意：</strong><ol>
<li>一般会给每一个单选框提供value值，指定其被选中后提交的值。</li>
<li>checked属性可以指定默认选中的值。</li>
</ol>
</li>
</ul>
</li>
<li>file：文件选择框</li>
<li>hidden：隐藏域，用于提交一些信息</li>
<li>submit：提交按钮</li>
<li>button：普通按钮</li>
<li>image：图片提交按钮，通过src指定图片路径</li>
</ul>
</li>
<li><p>&lt; label&gt;：指定输入项的文字描述信息</p>
<ul>
<li>label的for属性，一般会和input的id属性对应，点击label区域，会让input输入框获得焦点。</li>
</ul>
</li>
</ul>
</li>
<li><p>&lt; select&gt;：下拉列表</p>
<ul>
<li>子元素：&lt; option&gt;：指定列表项</li>
</ul>
</li>
<li><p>textarea：文本域</p>
<ul>
<li>cows：指定列数</li>
<li>rows：指定行数</li>
</ul>
</li>
</ul>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        Zhang SiFan
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <a href="http://www.beian.miit.gov.cn/" target="_black">浙ICP备20014029号</a>
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="小张日记"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>
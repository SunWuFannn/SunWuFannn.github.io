<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="一个让人日常头秃的笔记" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     小张日记
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/main.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="小张日记" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover6.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">小张日记</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Session" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/Session/"
    >Session</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/Session/" class="article-date">
  <time datetime="2020-05-14T16:00:00.000Z" itemprop="datePublished">2020-05-15</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession。</p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol>
<li>获取HttpSession对象：<br>HttpSession session = req.getSession()</li>
<li>使用HttpSession对象<br>Object getAttribute(String name)<br>void setAttribute(String name, Object value)<br>void removeAttribute(String name)</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Session的实现依赖于Cookie，在第一次请求时，如果没有Cookie，会在内存中创建一个Session对象，给它一个id值，然后响应时响应头中set-session:JSESSIONID=id值，再次请求时，请求头中Cookie中会有这个JSESSIONID=id值，从而找到内存中的session。</p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol>
<li>当客户端关闭后，服务器不关闭，两次获取session是否为同一个？<ul>
<li>默认情况下，不是同一个，因为客户端关闭了，代表这次会话结束了，再次打开客户端是开启新的对话，获取的是新的session对象。</li>
<li>如果在关闭客户端后，再打开时获取的session相同，则可以创建Cookie，键为JSESSIONID，值为session的id值，设置Cookie的最大存活时间，让Cookie持久化保存。</li>
</ul>
</li>
<li>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？<ul>
<li>不是同一个，但是要保证数据不丢失。tomcat会自动完成以下工作：<ul>
<li>session的钝化：在服务器正常关闭之前，把session对象序列化到硬盘上</li>
<li>session的活化：在服务器启动后，将session文件转化为内存中的session对象</li>
</ul>
</li>
<li>session的钝化将项目中的文件打包成war包丢到tomcat的webapps目录下即可，打开本地的tomcat运行项目后会自动活化，idea中无法完成这个操作，idea会钝化成功，但是活化会失败，因为重新启动服务器后，idea会删除原本存放session文件的那个目录，然后创建这个目录，所有无法读取到session文件。</li>
</ul>
</li>
<li>session的失效时间？即什么时候被销毁？<ol>
<li>服务器被关闭</li>
<li>session对象调用invalidate()</li>
<li>session的默认失效时间是30分钟，可以在tomcat的web.xml中修改这个默认失效时间，也可以在自己的项目中的web.xml修改这个失效时间</li>
</ol>
</li>
</ol>
<h3 id="Session的特点"><a href="#Session的特点" class="headerlink" title="Session的特点"></a>Session的特点</h3><ol>
<li>用于存储一次会话的多次请求的数据，存在服务器端</li>
<li>可以存储任意类型任意大小的数据</li>
</ol>
<h3 id="Session与Cookie的区别"><a href="#Session与Cookie的区别" class="headerlink" title="Session与Cookie的区别"></a>Session与Cookie的区别</h3><ol>
<li>Session存储数据在服务器端，Cookie在客户端</li>
<li>Session没有数据大小限制，Cookie有限制</li>
<li>Session数据安全，Cookie相对来说不安全</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Session/" rel="tag">Session</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-JSP" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/JSP/"
    >JSP</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/JSP/" class="article-date">
  <time datetime="2020-05-13T16:00:00.000Z" itemprop="datePublished">2020-05-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JSP/">JSP</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="入门学习"><a href="#入门学习" class="headerlink" title="入门学习"></a>入门学习</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul>
<li>java server pages：Java服务端页面<ul>
<li>可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码</li>
<li>用于简化书写</li>
</ul>
</li>
</ul>
<h3 id="原理：本质上就是一个servlet"><a href="#原理：本质上就是一个servlet" class="headerlink" title="原理：本质上就是一个servlet"></a>原理：本质上就是一个servlet</h3><h3 id="JSP的脚本：JSP定义Java代码的方式"><a href="#JSP的脚本：JSP定义Java代码的方式" class="headerlink" title="JSP的脚本：JSP定义Java代码的方式"></a>JSP的脚本：JSP定义Java代码的方式</h3><ol>
<li>&lt;% 代码 %&gt;：定义的java代码在service方法中，service方法中可以定义什么该脚本中就可以定义什么</li>
<li>&lt;%! 代码 %&gt;：定义的java代码在jsp转换后的java类的成员位置，可以定义成员方法成员变量代码块等等</li>
<li>&lt;%= 代码 %&gt;：定义的java代码会输出到页面上，输出语句中可以定义什么该脚本中就可以定义什么</li>
</ol>
<h3 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h3><ul>
<li>在JSP页面中不需要获取和创建，可以直接使用的对象</li>
<li>jsp一共有9个内置对象</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Cookie" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/12/Cookie/"
    >Cookie</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/12/Cookie/" class="article-date">
  <time datetime="2020-05-11T16:00:00.000Z" itemprop="datePublished">2020-05-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><ul>
<li><p>会话：一次会话中包含多次请求和响应。</p>
<ul>
<li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li>
</ul>
</li>
<li><p>功能：在一次会话范围内的多次请求间，共享数据。</p>
</li>
<li><p>方式：</p>
<ol>
<li>客户端会话技术：Cookie</li>
<li>服务器端会话技术：Session</li>
</ol>
</li>
<li><p><strong>概念：</strong>客户端会话技术，将数据保存到客户端。</p>
</li>
<li><p><strong>快速入门：</strong></p>
<ul>
<li><strong>使用步骤：</strong><ol>
<li>创建Cookie对象，绑定数据<ul>
<li>new Cookie(String name, String value)</li>
</ul>
</li>
<li>发送Cookie对象<ul>
<li>resp.addCookie(Cookie cookie)</li>
</ul>
</li>
<li>获取Cookie，拿到数据<ul>
<li>req.getCookies()</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>实现原理</strong></p>
<ul>
<li>基于响应体set-cookie和请求头cookie实现</li>
</ul>
</li>
<li><p><strong>cookie的细节</strong></p>
<ol>
<li>一次可不可以发送多个cookie？<ul>
<li>可以</li>
<li>可以创建多个cookie对象，然后用addCookie发送</li>
</ul>
</li>
<li>cookie在浏览器中保存多长时间？<ul>
<li>默认情况下，浏览器关闭后，cookie数据被销毁</li>
<li>持久化存储：setMaxAge(int seconds)<ol>
<li>正数：将Cookie数据写到硬盘的文件中，持久化存储，数值代表cookie存活时间</li>
<li>负数：默认值</li>
<li>零：删除cookie信息</li>
</ol>
</li>
</ul>
</li>
<li>cookie能不能存中文？<ul>
<li>在tomcat8之前，cookie中不能直接存储中文数据，需要将中文数据转码，一般采用URL编码</li>
<li>tomcat8之后可以存储</li>
</ul>
</li>
<li>cookie获取范围是多大？<ol>
<li>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中，cookie能不能共享？<ul>
<li>默认情况下，cookie不能共享</li>
<li>setPath(String path)：设置cookie的获取范围，默认情况下设置当前的虚拟目录</li>
<li>如果要共享，则可以将path设置为”/“</li>
</ul>
</li>
<li>不同的tomcat服务器获取cookie？<ul>
<li>setDomain(String path)：如果设置一级域名相同，那么多个服务器之间cookie可以共享</li>
<li>如：setDomain(“.baidu.com”)，那么tieba.baidu.com和news.baidu.com可以共享cookie</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>cookie的特点和作用</strong></p>
<ol>
<li>cookie存储数据在客户端浏览器，不太安全</li>
<li>浏览器对于单个cookie有限制(4kb左右)，以及对同一个域名下的总cookie数量也有限制 (20个左右)</li>
</ol>
<ul>
<li>作用：<ol>
<li>cookie一般用于存储少量的不太敏感的数据</li>
<li>在不登录的情况下，完成服务器对客户端的身份识别</li>
</ol>
</li>
</ul>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cookie/" rel="tag">Cookie</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-javaweb_HTTP" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/javaweb_HTTP/"
    >JavaWeb中HTTP相关的粗略描述</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/javaweb_HTTP/" class="article-date">
  <time datetime="2020-05-07T16:00:00.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h1><ul>
<li><p>概念：Hyper Text Transfer Protocol 超文本传输协议</p>
<ul>
<li>传输协议：定义了客户端和服务器通信时，发送数据的格式。</li>
<li>特点：<ol>
<li>基于TCP/IP的高级协议</li>
<li>默认端口号：80</li>
<li>基于请求/响应模型的：一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
</li>
</ul>
</li>
<li><p>历史版本：</p>
<ul>
<li>1.0：每次请求响应都会建立新的连接</li>
<li>1.1：复用连接</li>
</ul>
</li>
</ul>
<hr>
<h3 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h3><ol>
<li><p>请求行</p>
<ul>
<li>请求方式 请求url 请求协议/版本</li>
<li>如：GET /login.html HTTP/1.1</li>
<li>请求方式：<ul>
<li>HTTP有7种请求方式，常见的有两种：<ul>
<li>GET：请求参数在请求行中，在url后。请求的url长度是有限制的。不太安全。</li>
<li>POST：请求参数在请求体中。请求的url长度是无限制的。相对安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头：客户端浏览器告诉服务器一些信息</p>
<ul>
<li>请求头名：请求头值</li>
<li>常见的请求头：<ol>
<li>Host: 主机</li>
<li>User-Agent: 浏览器告诉服务器，我访问你使用的浏览器版本信息<ul>
<li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li>
</ul>
</li>
<li>Referer: 告诉服务器，当前请求从哪里来<ul>
<li>作用：<ol>
<li>防盗链：</li>
<li>统计工作：</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>请求空行：空行，用于分割post请求头和请求体的</p>
</li>
<li><p>请求体（正文）</p>
<ul>
<li>封装post请求消息的请求参数的</li>
</ul>
</li>
</ol>
<hr>
<h3 id="响应消息数据格式"><a href="#响应消息数据格式" class="headerlink" title="响应消息数据格式"></a>响应消息数据格式</h3><ol>
<li>响应行：<ul>
<li>组成：协议/版本 响应状态码 状态码描述</li>
<li>响应状态码：服务器告诉客户端浏览器本次请求和响应的状态，状态码都是三位数字<ul>
<li>状态分类：<ol>
<li>1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后发送1xx的状态码</li>
<li>2xx：成功。代表：200</li>
<li>3xx：重定向。代表：302（重定向），304（访问缓存）</li>
<li>4xx：客户端错误。代表：404（请求路径没有对应的资源），405（请求方式没有对应的方法）</li>
<li>5xx：服务器端错误。代表：500（服务器内部出现异常）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>响应头<ul>
<li>格式：头名称:值</li>
<li>常见的响应头：<ol>
<li>Content-Type：服务器告诉客户端浏览器本次响应体的数据格式及编码格式</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据。默认值是<code>in-line 在当前页面内打开</code>，可以设置为<code>attachment;filename=xxx 以附件形式打开响应体</code></li>
</ol>
</li>
</ul>
</li>
<li>响应空行</li>
<li>响应体：传输的数据</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Request" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/Request/"
    >Request</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/Request/" class="article-date">
  <time datetime="2020-05-07T16:00:00.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><p>Request和Response对象的原理：</p>
<ol>
<li>Request和Response对象是由服务器创建的。我们来使用它们。</li>
<li>Request对象来获取请求消息，Response对象来设置响应消息。</li>
</ol>
<h3 id="Request对象继承体系结构"><a href="#Request对象继承体系结构" class="headerlink" title="Request对象继承体系结构"></a>Request对象继承体系结构</h3><p>HttpServletRequest接口继承ServletRequest接口。<br>org.apache.catalina.connector.RequestFacade类（tomcat实现）实现HttpServletRequest接口。</p>
<h3 id="Request功能："><a href="#Request功能：" class="headerlink" title="Request功能："></a>Request功能：</h3><ol>
<li><p>获取请求消息数据：</p>
<ol>
<li>获取请求行数据：<ul>
<li>方法：<ol>
<li>获取请求方式：String getMethod()</li>
<li>获取虚拟目录：String getContextPath()</li>
<li>获取Servlet路径：String getServletPath()</li>
<li>获取<strong>GET方式请求参数：String getQueryString()</strong></li>
<li>获取请求URI：<ul>
<li>String getRequestURI()：返回虚拟目录加servlet路径</li>
<li>String getRequestURI()：返回浏览器地址栏中的地址，即http://…….形式的</li>
</ul>
</li>
<li>获取协议及版本：String getProtocol()</li>
<li>获取客户机ip地址：String getRemoteAddr()</li>
</ol>
</li>
</ul>
</li>
<li>获取请求头数据：<ul>
<li>方法：<ul>
<li>String getHeader(String name)：通过请求头的名称获取请求头的值</li>
<li>Enmueration&lt; string&gt; getHeaderNames()：获取所有请求头的名称</li>
</ul>
</li>
</ul>
</li>
<li>获取请求体数据：<ul>
<li>请求体只有在POST请求方式中才有，请求体中封装了POST请求的参数</li>
<li>步骤：<ol>
<li>获取流对象<ul>
<li>BufferedReader getReader()：获取字符输入流，只能操作字符数据</li>
<li>ServletInputStream getInputStream()：获取字节输入流，可以操作所有数据类型数据</li>
</ul>
</li>
<li>再从流对象中拿数据</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>其他功能：</p>
<ol>
<li><p>获取请求参数通用方式：</p>
<ol>
<li>String getParameter(String name)：根据参数名称获取参数值</li>
<li>String[] getParameterValues(String name)：根据参数名称获取参数值的数组</li>
<li>Enmueration&lt; string&gt; getParameterNames()：获取所有请求的参数名称</li>
<li>Map&lt; String, String[]&gt; getParameterMap()：获取所有参数的Map集合</li>
</ol>
<ul>
<li>中文乱码问题：<ul>
<li>get方式：tomcat8已经将get方式乱码问题解决了</li>
<li>post方式：在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>请求转发：一种在服务器内部的资源跳转方式</p>
<ul>
<li>步骤：<ol>
<li>通过request对象获取请求转发对象：RequestDispatcher getRequestDispatcher(String path)</li>
<li>使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)</li>
</ol>
</li>
<li>特点：<ol>
<li>浏览器地址栏路径不发生变化</li>
<li>只能转发到当前服务器内部资源中</li>
<li>转发是一次请求</li>
</ol>
</li>
</ul>
</li>
<li><p>共享数据：</p>
<ul>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域：代表一次请求的范围，一般用于请求转发中的多个资源中共享数据</li>
<li>方法：<ol>
<li>void setAttribute(String name, Object obj)：存储数据</li>
<li>Object getAttribute(String name)：通过键获取值</li>
<li>void removeAttribute(String name)：通过键移除键值对</li>
</ol>
</li>
</ul>
</li>
<li><p>获取ServletContext：</p>
<ul>
<li>ServletContext getServletContext()</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="BeanUtils工具类，简化数据封装"><a href="#BeanUtils工具类，简化数据封装" class="headerlink" title="BeanUtils工具类，简化数据封装"></a>BeanUtils工具类，简化数据封装</h3><ul>
<li><p>用于封装JavaBean的</p>
</li>
<li><p><strong>JavaBean：标准的java类</strong></p>
<ul>
<li><p>要求：</p>
<ol>
<li>类必须被public修饰</li>
<li>必须提供空参的构造器</li>
<li>成员变量必须使用private修饰</li>
<li>提供public修饰的getter和setter</li>
</ol>
</li>
<li><p>功能：封装数据</p>
</li>
</ul>
</li>
<li><p>概念：</p>
<ul>
<li><p>成员变量</p>
</li>
<li><p>属性：setter和getter方法截取后的产物</p>
<ul>
<li><p>如</p>
<pre><code>public void setHehe(String gender){
     this.gender = gender;
}</code></pre></li>
<li><p>其中成员变量是gender，属性是hehe</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方法：</p>
<ol>
<li>setProperty()：设置JavaBean对象属性值</li>
<li>getProperty()：获取JavaBean对象属性值</li>
<li>populate(Object obj，Map map)：将map集合的键值对信息封装到对于的JavaBean对象中</li>
</ol>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Request/" rel="tag">Request</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Response" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/Response/"
    >Response</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/Response/" class="article-date">
  <time datetime="2020-05-07T16:00:00.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><ul>
<li><strong>设置响应消息：</strong><ol>
<li>设置响应行<ul>
<li>设置状态码：setStatus(int sc)</li>
</ul>
</li>
<li>设置响应头<ul>
<li>setHeader(Sting name, Sring value)</li>
</ul>
</li>
<li>设置响应体：<ul>
<li>使用步骤：<ol>
<li>获取输出流</li>
<li>使用输出流将数据输出到客户端浏览器</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><ol>
<li>完成重定向</li>
</ol>
<ul>
<li><p>重定向：资源跳转的方式</p>
</li>
<li><p>代码：</p>
<pre><code>//设置状态码
resp.setStatus(302);
//设置重定向资源location路径
resp.setHeader(&quot;location&quot;,&quot;/javaweb_tomcat_war_exploded/ResponseDemo02&quot;);</code></pre></li>
<li><p>简化写法：<code>resp.sendRedirect(&quot;/javaweb_tomcat_war_exploded/ResponseDemo02&quot;);</code></p>
</li>
<li><p>重定向的特点：</p>
<ol>
<li>浏览器地址栏发生变化</li>
<li>重定向可以访问其他站点（服务器）的资源</li>
<li>重定向是两次请求，不能使用request对象共享数据</li>
</ol>
</li>
<li><p>路径写法：</p>
<ol>
<li>路径分类：<ol>
<li>相对路径：通过相对路径不可以确定唯一资源<ul>
<li>如：./index.html</li>
<li>不以/开业，以.开头的路径</li>
<li>规则：找到当前资源和目标资源之间的关系<ul>
<li>./：当前目录</li>
<li>../：后退一级目录</li>
</ul>
</li>
</ul>
</li>
<li>绝对路径：通过相对路径可以确定唯一资源<ul>
<li>如：<a href="http://localhost/day15/responseDemo2" target="_blank" rel="noopener">http://localhost/day15/responseDemo2</a></li>
<li>以/开头的路径</li>
<li>规则：判断定义的路径给谁用<ul>
<li>给客户端浏览器使用：需要加虚拟目录（项目的访问路径）<ul>
<li>建议虚拟目录动态获取：<code>request.getContextPath()</code></li>
</ul>
</li>
<li>给服务使用：不需要加虚拟目录</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>服务器输出字符数据到浏览器</p>
<ul>
<li>步骤：<ol>
<li>获取字符输出流</li>
<li>输出数据</li>
</ol>
</li>
<li><strong>注意：乱码问题</strong><ul>
<li>获取的流的默认编码格式是ISO-8859-1，需要设置该流的默认编码，告诉浏览器响应体使用的编码。</li>
<li><code>resp.setContentType(&quot;text/html;charset=utf-8&quot;);</code>在获取流之前设置</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器输出字节数据到浏览器</p>
<ul>
<li>步骤：<ol>
<li>获取字节输出流</li>
<li>输出数据</li>
</ol>
</li>
</ul>
</li>
<li><p>验证码</p>
<pre><code>public class CheckCodeServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    int width = 100;
    int height = 50;

    //创建对象，在内存中和代表图片（验证码图片对象）
    BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
    //美化图片
    //获取画笔对象
    Graphics graphics = bufferedImage.getGraphics();
    //设置填充的背景色
    graphics.setColor(Color.PINK);
    //设置填充开始的坐标以及宽度高度，填充一个矩形
    graphics.fillRect(0, 0, width, height);
    //设置边框的颜色
    graphics.setColor(Color.BLUE);
    //从坐标处画一个边框，因为边框的有1px的宽度，所有宽度和高度要减去1
    graphics.drawRect(0, 0, width - 1, height - 1);
    //设置验证码的颜色
    graphics.setColor(new Color(214, 24, 215));
    //随机生成4个验证码，放入图中
    String str = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm0123456789&quot;;
    Random random = new Random();
    for (int i = 1; i &lt;= 4; i++) {
        int index = random.nextInt(str.length());
        char ch = str.charAt(index);
        graphics.drawString(ch + &quot;&quot;, width / 5 * i, height / 2);
    }
    //设置干扰线的颜色
    graphics.setColor(Color.RED);
    //随机生成10条干扰线放入图中
    for (int i = 0; i &lt; 10; i++) {
        int x1 = random.nextInt(width);
        int y1 = random.nextInt(height);
        int x2 = random.nextInt(width);
        int y2 = random.nextInt(height);
        graphics.drawLine(x1, y1, x2, y2);
    }
    //将图片输出到页面
    ImageIO.write(bufferedImage, &quot;jpg&quot;, resp.getOutputStream());
}</code></pre></li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Response/" rel="tag">Response</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-ServletContext" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/ServletContext/"
    >ServletContext</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/ServletContext/" class="article-date">
  <time datetime="2020-05-07T16:00:00.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h1><h3 id="概念：代表整个web应用，可以和程序的容器（服务器）来通信"><a href="#概念：代表整个web应用，可以和程序的容器（服务器）来通信" class="headerlink" title="概念：代表整个web应用，可以和程序的容器（服务器）来通信"></a>概念：代表整个web应用，可以和程序的容器（服务器）来通信</h3><h3 id="获取："><a href="#获取：" class="headerlink" title="获取："></a>获取：</h3><ol>
<li>通过request对象来获取<ul>
<li>request.getServletContext()</li>
</ul>
</li>
<li>通过HttpServlet获取<ul>
<li>this.getServletContext()</li>
</ul>
</li>
</ol>
<ul>
<li><strong>两种方法获取只能获取一个，获取的是同一个</strong></li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ol>
<li><p>获取MIME类型</p>
<ul>
<li>MIME类型：在互联网通信过程中定义的一种文件数据类型<ul>
<li>格式：大类型/小类型 text/html image/jpeg</li>
</ul>
</li>
<li>获取：String getMimeType(String file)</li>
</ul>
</li>
<li><p>域对象，共享数据</p>
<ol>
<li>setAttribute(String name, Object value)</li>
<li>getAttribute(String name)</li>
<li>removeAttribute(String name)</li>
</ol>
<ul>
<li><strong>这个域的范围：所有用户所有请求的数据</strong></li>
</ul>
</li>
<li><p>获取文件的真实（服务器）路径</p>
<ol>
<li>方法：String getRealPath(String Path)<ul>
<li>web目录下获取，直接<code>/a.txt</code></li>
<li>WEB-INF目录下获取，<code>/WEB-INF/a.txt</code></li>
<li>src目录下获取，<code>/WEB-INF/classes/a.txt</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="文件下载案例"><a href="#文件下载案例" class="headerlink" title="文件下载案例"></a>文件下载案例</h3><pre><code>protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
    //通过传递的参数获取要下载的文件的文件名
    String filename = req.getParameter(&quot;filename&quot;);
    ServletContext servletContext = this.getServletContext();
    //通过ServletContext获取要下载文件的真实路径
    String realPath = servletContext.getRealPath(&quot;/img/&quot; + filename);
    //创建字节输入流，用于读取文件
    FileInputStream fis = new FileInputStream(realPath);
    //获取发送文件的MIME数据类型
    String mimeType = servletContext.getMimeType(filename);
    //设置content-type响应头
    resp.setHeader(&quot;content-type&quot;, mimeType);
    //设置content-disposition响应头，设置成附件打开
    resp.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot; + filename);
    //获取字节输出流
    ServletOutputStream os = resp.getOutputStream();
    byte[] bytes = new byte[1024];
    int len = 0;
    //下载文件
    while ((len = fis.read(bytes)) != -1) {
        os.write(bytes, 0, len);
    }
    //释放资源
    fis.close();
}</code></pre><ul>
<li><strong>注意：在弹出的下载框中会遇到中文文件名乱码问题，需要针对不同浏览器进行解决，可以先获取浏览器的版本信息，然后设置编码，网上有很多解决这个问题的工具类，可以咨询查找。</strong></li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ServletContext/" rel="tag">ServletContext</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Bootstrap" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/05/Bootstrap/"
    >Bootstrap</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/05/Bootstrap/" class="article-date">
  <time datetime="2020-05-04T16:00:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Bootstrap/">Bootstrap</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><ul>
<li><p>概念：一个前端开发的框架。Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。</p>
<ul>
<li>框架：一个半成品软件。开发人员可以在框架基础上再进行开发，简化编码。</li>
<li>好处：<ol>
<li>定义了很多的css样式和js插件。我们开发人员可以直接使用这些样式和插件得到丰富的页面效果。</li>
<li>响应式布局。<ul>
<li>同一套页面可以兼容不同分辨率的设备。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li>下载Bootstrap</li>
<li>在项目中将下载解压完的文件中的三个文件夹复制</li>
<li>创建html页面，引入必要的资源文件</li>
</ol>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><ul>
<li><p><strong>实现</strong>：依赖于栅格系统。</p>
<ul>
<li>栅格系统：将一行平均分割成12个格子，可以指定元素占几个格子。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>定义容器<ul>
<li>容器分类：<ol>
<li>container：固定宽度。每一种设备的宽度都是一个不同的固定值</li>
<li>container-fluid：每一种设备都是100%宽度</li>
</ol>
</li>
</ul>
</li>
<li>定义行 样式：row</li>
<li>定义元素。指定该元素在不同的设备上占用的格子数目 样式：col-设备代号-格子数目<ul>
<li>设备代号：<ol>
<li>xs：超小屏幕 手机(&lt;768px)</li>
<li>sm：小屏幕 平板(&gt;=768px)</li>
<li>md：中等屏幕 桌面显示器(&gt;=992px)</li>
<li>lg：大屏幕 大桌面显示器(&gt;=1200px)</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>注意：</strong><ol>
<li>一行中如果格子数目超过12，则超出部分自动换行</li>
<li>栅格类属性可以向上兼容</li>
<li>如果真实设备的宽度小于了设置的栅格类属性的设备代码的最小值，会一个元素占满一整行</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><p>全局CSS样式：</p>
<ul>
<li>按钮：例如 <code>btn btn-default</code></li>
<li>图片：<ul>
<li>响应式图片 <code>class=&quot;img-responsive&quot;</code></li>
<li>图片形状例如 <code>class=&quot;img-rounded&quot;</code></li>
</ul>
</li>
<li>表格：查看文档</li>
<li>表单：查看文档</li>
</ul>
<p>组件：</p>
<ul>
<li>导航条：navbar</li>
<li>分页条：pagination</li>
</ul>
<p>插件：</p>
<ul>
<li>轮播图：Carousel</li>
</ul>
<hr>
<p>Bootstrap更多用法请自询查找文档，上面很详细。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bootstrap/" rel="tag">Bootstrap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-xml" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/05/xml/"
    >XML</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/05/xml/" class="article-date">
  <time datetime="2020-05-04T16:00:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/XML/">XML</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ul>
<li><p><strong>概念：Extersible Markup Language 可扩展标记语言</strong></p>
<ul>
<li>可扩展：标签都是自定义的。</li>
</ul>
</li>
<li><p><strong>功能：</strong></p>
<ul>
<li>存储数据：<ol>
<li>配置文件</li>
<li>在网络中传输</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>与html的区别：</strong></p>
<ol>
<li>xml标签都是自定义的，html是预定义的</li>
<li>xml语法严格，html语法松散</li>
<li>xml存储数据，html展示数据</li>
</ol>
</li>
</ul>
<hr>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ol>
<li>xml第一行必须定义为文档声明</li>
<li>xml文档中有且仅有一个根标签</li>
<li>属性值必须使用引号引起来</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写</li>
</ol>
<h3 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h3><ol>
<li><p>文档声明</p>
<ol>
<li>格式<code>&lt;?xml 属性列表 ?&gt;</code></li>
<li>属性列表：<ul>
<li>version：版本号，必须的属性</li>
<li>encoding：编码格式，告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li>
<li>standalone：是否独立，是否依赖其他文件</li>
</ul>
</li>
</ol>
</li>
<li><p>指令：结合css的，了解即可。</p>
</li>
<li><p>标签：标签名称自定义的。</p>
<ul>
<li>规则：<ol>
<li>数字或者标点符号不能开头</li>
<li>名称不能以字母xml或者XML开头</li>
<li>名称中不能包含空格</li>
</ol>
</li>
</ul>
</li>
<li><p>属性：id值唯一。</p>
</li>
<li><p>文本内容：</p>
<ul>
<li><p>CDATA区：在该区域的文字会被原样展示。</p>
<pre><code>&lt;![CDATA[
    文本内容
]]&gt;</code></pre></li>
</ul>
</li>
</ol>
<h3 id="约束：规定xml文档的编写规则"><a href="#约束：规定xml文档的编写规则" class="headerlink" title="约束：规定xml文档的编写规则"></a>约束：规定xml文档的编写规则</h3><ul>
<li><p>分类：</p>
<ol>
<li>DTD：一种简单的约束技术</li>
<li>Schemea：一种复杂的约束技术</li>
</ol>
</li>
<li><p>DTD：</p>
<ul>
<li>引入dtd文档到xml文档中<ol>
<li>内部dtd：<ul>
<li><code>&lt;!DOCTYPE 根标签名 [dtd文件中具体内容]&gt;</code></li>
</ul>
</li>
<li>外部dtd：<ul>
<li>本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code></li>
<li>外部：<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;随便取个文件名&quot; &quot;dtd文件的位置URL&quot;&gt;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Schema：</p>
<ul>
<li>引入：<ol>
<li>填写xml文档的根元素</li>
<li>引入xsi前缀 xmlns:xsi=”…”</li>
<li>引入xsd文件命名空间 xsi:schemaLocation=”….”</li>
<li>为每一个xsd约束声明一个前缀，作为标识 xmlns:…=”….”</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="解析：操作xml文档，将文档中数据读取到内存中"><a href="#解析：操作xml文档，将文档中数据读取到内存中" class="headerlink" title="解析：操作xml文档，将文档中数据读取到内存中"></a>解析：操作xml文档，将文档中数据读取到内存中</h3><ul>
<li><p>操作xml文档：</p>
<ol>
<li>解析（读取）</li>
<li>写入：将内存中的数据保存到xml文档中，持久化的存储</li>
</ol>
</li>
<li><p>解析xml的方式：</p>
<ol>
<li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<ul>
<li>优点：操作方便，可以对文档进行CRUD的操作</li>
<li>缺点：占内存</li>
</ul>
</li>
<li>SAX：逐行读取，基于事件驱动的<ul>
<li>优点：不占内存</li>
<li>缺点：只能读取不能增删改</li>
</ul>
</li>
</ol>
</li>
<li><p>xml常见的解析器：</p>
<ol>
<li>JAXP：sun公司提供的解析器，支持DOM和SAX</li>
<li>DOM4J：一款非常优秀的解析器，DOM方式</li>
<li>Jsoup：是一款HTML解析器，但是比较好用，也可以用于解析XML，DOM方式</li>
<li>PULL：Andriod操作系统内置的解析器，SAX方式</li>
</ol>
</li>
</ul>
<h3 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h3><ul>
<li><p>快速入门：</p>
<ul>
<li>步骤：<ol>
<li>导入jar包</li>
<li>获取Document对象</li>
<li>获取对应的标签Element对象</li>
<li>获取数据</li>
</ol>
</li>
</ul>
</li>
<li><p>对象的使用：</p>
<ol>
<li><p>Jsoup：工具类，可以解析html文或xml文档，返回Document</p>
<ul>
<li>parse：解析html文或xml文档，返回Document对象<ul>
<li>parse(File in, String charsetName)：解析xml或html文件</li>
<li>parse(String html)：解析xml或html字符串</li>
<li>parse(URL url, int timeoustMillis)：通过网络路径获取指定的html或xml的文档对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Document：文档对象，代表内存中得到DOM树</p>
<ul>
<li>获取Element对象：<ul>
<li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li>
<li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li>
<li>getElementsByAttributeValue(String key，String value)：根据对应的属性名称和属性值获取元素对象集合</li>
<li>getElementsById(String id)：根据id属性值获取唯一Element对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Elements：元素Element对象的集合。可以当做ArrayList&lt; Element&gt;来使用</p>
</li>
<li><p>Element：元素对象</p>
<ol>
<li>获取子元素对象：<ul>
<li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li>
<li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li>
<li>getElementsByAttributeValue(String key，String value)：根据对应的属性名称和属性值获取元素对象集合</li>
<li>getElementsById(String id)：根据id属性值获取唯一Element对象</li>
</ul>
</li>
<li>获取属性值：<ul>
<li>String attr(String key)：根据属性名称获取属性值</li>
</ul>
</li>
<li>获取文本：<ul>
<li>String text()；纯文本内容</li>
<li>String html()：包括子标签的内容</li>
</ul>
</li>
</ol>
</li>
<li><p>Node：节点对象</p>
<ul>
<li>是Document和Element的父类</li>
</ul>
</li>
</ol>
</li>
<li><p>快速查询方式：</p>
<ol>
<li><p>selector：选择器</p>
<ul>
<li>使用的方法：Elements select(String cssQuery)<ul>
<li>语法：参考selector类中定义的语法</li>
</ul>
</li>
</ul>
</li>
<li><p>XPath：XML路径语言，用来确定XML文档中某部分位置的语言</p>
<ul>
<li>使用Jsoup的Xpath需要额外导入jar包</li>
<li>查询XPath语法完成查询</li>
</ul>
</li>
</ol>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XML/" rel="tag">XML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Tomcat" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/05/Tomcat/"
    >Tomcat和Servlet</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/05/Tomcat/" class="article-date">
  <time datetime="2020-05-04T16:00:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>web服务器软件。</p>
<ul>
<li>服务器：安装了服务器软件的计算机。</li>
<li>服务器软件：接收用户请求，处理请求，做出响应。</li>
<li>web服务器软件：接收用户请求，处理请求，做出响应。<ul>
<li>在web服务器软件中可以部署web项目，让用户通过浏览器访问这些项目。</li>
<li>web容器</li>
</ul>
</li>
</ul>
<p>常见的java相关的web服务器软件：</p>
<ul>
<li>webLogic：Oracle公司，大型javaEE服务器，支持所有的javaEE规范，收费。</li>
<li>webSphere：IBM公司，大型javaEE服务器，支持所有的javaEE规范，收费。</li>
<li>JBOSS：JBOSS公司，大型javaEE服务器，支持所有的javaEE规范，收费。</li>
<li>Tomcat：Apache基金组织，中小型javaEE服务器，仅仅支持少量javaEE规范，开源免费。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>部署项目的方式：<ol>
<li>直接将项目放在webapps文件夹下。<ul>
<li>简化部署：将项目打包成一个war包，再将war包放到webapps目录下，war包会自动解压缩。</li>
</ul>
</li>
<li>配置conf/server.xml文件，在&lt; host&gt;标签体中配置<code>&lt;Context docBase=&quot;项目存放路径&quot; path=&quot;/虚拟目录&quot; /&gt;</code></li>
<li>在conf/Catalina/localhost创建任意名称的xml文件，在文件中编写<code>&lt;Context docBase=&quot;项目存放路径&quot; /&gt;</code>，虚拟目录就是xml文件的名称。</li>
</ol>
</li>
</ul>
<h1 id="Servlet简单学习"><a href="#Servlet简单学习" class="headerlink" title="Servlet简单学习"></a>Servlet简单学习</h1><p>运行在服务器端的小程序。</p>
<ul>
<li>Servlet就是一个接口，定义了java类被浏览器访问到(tomcat识别)的规则。</li>
<li>将来我们自定义一个类，实现Servlet接口，复写方法。</li>
</ul>
<h2 id="Servlet快速入门"><a href="#Servlet快速入门" class="headerlink" title="Servlet快速入门"></a>Servlet快速入门</h2><ol>
<li><p>创建javaEE的项目</p>
</li>
<li><p>定义一个类，必须实现Servlet接口</p>
</li>
<li><p>实现接口中的抽象方法</p>
</li>
<li><p>配置Servlet</p>
<ul>
<li><p>web.xml中配置：</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;
    &lt;servlet-class&gt;web.servlet.ServletDemo01&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre></li>
</ul>
</li>
</ol>
<h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><ol>
<li>当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的servlet的资源路径。</li>
<li>查找web.xml文件是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</li>
<li>如果有则在找到对应的<code>&lt;servlet-class&gt;</code>全类名。</li>
<li>tomcat会将字节码文件加载进内存，并且创建其对象。</li>
<li>调用其方法。</li>
</ol>
<h2 id="ervlet的生命周期："><a href="#ervlet的生命周期：" class="headerlink" title="ervlet的生命周期："></a>ervlet的生命周期：</h2><ol>
<li><p>被创建：执行init方法，只执行一次。</p>
<ul>
<li><p>servlet什么时候被创建？</p>
<ul>
<li>默认情况下，第一次访问时，servlet被创建</li>
<li>可以配置执行servlet的创建时机<ul>
<li>在<code>&lt;servlet&gt;</code>标签下配置<ol>
<li>第一次被访问时，创建<ul>
<li><code>&lt;load-on-startup&gt;</code>的值为负数</li>
</ul>
</li>
<li>在服务器启动时，创建<ul>
<li><code>&lt;load-on-startup&gt;</code>的值为0或正数</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>servlet的init方法只执行一次，说明一个servlet在内存中只存在一个对象，servlet是单例的。</p>
<ul>
<li>多个用户同时访问时，可能存在线程安全问题。<ul>
<li>解决：尽量不要在servlet中定义成员变量。即使定义了成员变量，也不要对其修改值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>提供服务：执行service方法，可以执行多次。</p>
<ul>
<li>每次访问servlet时都会执行一次。</li>
</ul>
</li>
<li><p>被销毁：执行destroy方法，只执行一次。</p>
<ul>
<li>servlet被销毁时执行一次，服务器正常关闭时。</li>
</ul>
</li>
</ol>
<h2 id="Servlet3-0及以上："><a href="#Servlet3-0及以上：" class="headerlink" title="Servlet3.0及以上："></a>Servlet3.0及以上：</h2><ul>
<li>好处：<ul>
<li>支持注解配置。可以不需要web.xml。</li>
</ul>
</li>
<li>步骤：<ol>
<li>创建javaEE项目，选择servlet版本3.0以上，可以不创建web.xml。</li>
<li>定义一个类实现Servlet接口。</li>
<li>复写方法。<ol start="4">
<li>在类上使用@WebServlet(“资源路径”)注解进行配置。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Servlet的体系结构："><a href="#Servlet的体系结构：" class="headerlink" title="Servlet的体系结构："></a>Servlet的体系结构：</h2><ul>
<li>Servlet，GenericServlet，HttpServlet<ol>
<li>GenericServlet继承自Servlet，将Servlet接口中除service方法都进行了默认空实现，只将service方法作为抽象方法，定义时只需实现service方法即可。</li>
<li>HttpServlet继承自GenericServlet，是对http协议的一种封装，简化操作。定义时可以复写doGet/doPost方法。</li>
</ol>
</li>
</ul>
<h2 id="Servlet相关配置："><a href="#Servlet相关配置：" class="headerlink" title="Servlet相关配置："></a>Servlet相关配置：</h2><ol>
<li>urlpartten：Servlet访问路径<ol>
<li>一个Servlet可以定义多个访问路径：@WebServlet({“/路径1”，”/路径2”，”/路径3”})。</li>
<li>路径定义规则：<ol>
<li>/xxx</li>
<li>/xxxx/xx/xxx：多层路径，目录结构。</li>
<li>*.后缀名</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="IDEA与Tomcat的相关配置"><a href="#IDEA与Tomcat的相关配置" class="headerlink" title="IDEA与Tomcat的相关配置"></a>IDEA与Tomcat的相关配置</h1><ol>
<li><p>IDEA会为每一个Tomacat部署的项目单独建立一份配置文件。</p>
<ul>
<li>查看控制台的log中的CATALINA_BASE。</li>
</ul>
</li>
<li><p>工作空间项目和Tomacat部署的web项目是两个存在。</p>
<ul>
<li>Tomcat真正访问的是“Tomacat部署的web项目”，“Tomacat部署的web项目”对应着的是“工作空间项目”的web目录下的所有资源。</li>
<li>WEB-INF目录下的资源不能被浏览器直接访问。</li>
<li>断点调试：使用Debug启动而不是Run。</li>
</ul>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        Zhang SiFan
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <a href="http://www.beian.miit.gov.cn/" target="_black">浙ICP备20014029号</a>
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="小张日记"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>
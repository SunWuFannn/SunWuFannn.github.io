<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="一个让人日常头秃的笔记" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     小张日记
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/main.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="小张日记" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover6.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">小张日记</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Bootstrap" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/05/Bootstrap/"
    >Bootstrap</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/05/Bootstrap/" class="article-date">
  <time datetime="2020-05-04T16:00:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Bootstrap/">Bootstrap</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><ul>
<li><p>概念：一个前端开发的框架。Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。</p>
<ul>
<li>框架：一个半成品软件。开发人员可以在框架基础上再进行开发，简化编码。</li>
<li>好处：<ol>
<li>定义了很多的css样式和js插件。我们开发人员可以直接使用这些样式和插件得到丰富的页面效果。</li>
<li>响应式布局。<ul>
<li>同一套页面可以兼容不同分辨率的设备。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li>下载Bootstrap</li>
<li>在项目中将下载解压完的文件中的三个文件夹复制</li>
<li>创建html页面，引入必要的资源文件</li>
</ol>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><ul>
<li><p><strong>实现</strong>：依赖于栅格系统。</p>
<ul>
<li>栅格系统：将一行平均分割成12个格子，可以指定元素占几个格子。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>定义容器<ul>
<li>容器分类：<ol>
<li>container：固定宽度。每一种设备的宽度都是一个不同的固定值</li>
<li>container-fluid：每一种设备都是100%宽度</li>
</ol>
</li>
</ul>
</li>
<li>定义行 样式：row</li>
<li>定义元素。指定该元素在不同的设备上占用的格子数目 样式：col-设备代号-格子数目<ul>
<li>设备代号：<ol>
<li>xs：超小屏幕 手机(&lt;768px)</li>
<li>sm：小屏幕 平板(&gt;=768px)</li>
<li>md：中等屏幕 桌面显示器(&gt;=992px)</li>
<li>lg：大屏幕 大桌面显示器(&gt;=1200px)</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>注意：</strong><ol>
<li>一行中如果格子数目超过12，则超出部分自动换行</li>
<li>栅格类属性可以向上兼容</li>
<li>如果真实设备的宽度小于了设置的栅格类属性的设备代码的最小值，会一个元素占满一整行</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><p>全局CSS样式：</p>
<ul>
<li>按钮：例如 <code>btn btn-default</code></li>
<li>图片：<ul>
<li>响应式图片 <code>class=&quot;img-responsive&quot;</code></li>
<li>图片形状例如 <code>class=&quot;img-rounded&quot;</code></li>
</ul>
</li>
<li>表格：查看文档</li>
<li>表单：查看文档</li>
</ul>
<p>组件：</p>
<ul>
<li>导航条：navbar</li>
<li>分页条：pagination</li>
</ul>
<p>插件：</p>
<ul>
<li>轮播图：Carousel</li>
</ul>
<hr>
<p>Bootstrap更多用法请自询查找文档，上面很详细。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bootstrap/" rel="tag">Bootstrap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-xml" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/05/xml/"
    >XML</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/05/xml/" class="article-date">
  <time datetime="2020-05-04T16:00:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/XML/">XML</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ul>
<li><p><strong>概念：Extersible Markup Language 可扩展标记语言</strong></p>
<ul>
<li>可扩展：标签都是自定义的。</li>
</ul>
</li>
<li><p><strong>功能：</strong></p>
<ul>
<li>存储数据：<ol>
<li>配置文件</li>
<li>在网络中传输</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>与html的区别：</strong></p>
<ol>
<li>xml标签都是自定义的，html是预定义的</li>
<li>xml语法严格，html语法松散</li>
<li>xml存储数据，html展示数据</li>
</ol>
</li>
</ul>
<hr>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ol>
<li>xml第一行必须定义为文档声明</li>
<li>xml文档中有且仅有一个根标签</li>
<li>属性值必须使用引号引起来</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写</li>
</ol>
<h3 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h3><ol>
<li><p>文档声明</p>
<ol>
<li>格式<code>&lt;?xml 属性列表 ?&gt;</code></li>
<li>属性列表：<ul>
<li>version：版本号，必须的属性</li>
<li>encoding：编码格式，告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li>
<li>standalone：是否独立，是否依赖其他文件</li>
</ul>
</li>
</ol>
</li>
<li><p>指令：结合css的，了解即可。</p>
</li>
<li><p>标签：标签名称自定义的。</p>
<ul>
<li>规则：<ol>
<li>数字或者标点符号不能开头</li>
<li>名称不能以字母xml或者XML开头</li>
<li>名称中不能包含空格</li>
</ol>
</li>
</ul>
</li>
<li><p>属性：id值唯一。</p>
</li>
<li><p>文本内容：</p>
<ul>
<li><p>CDATA区：在该区域的文字会被原样展示。</p>
<pre><code>&lt;![CDATA[
    文本内容
]]&gt;</code></pre></li>
</ul>
</li>
</ol>
<h3 id="约束：规定xml文档的编写规则"><a href="#约束：规定xml文档的编写规则" class="headerlink" title="约束：规定xml文档的编写规则"></a>约束：规定xml文档的编写规则</h3><ul>
<li><p>分类：</p>
<ol>
<li>DTD：一种简单的约束技术</li>
<li>Schemea：一种复杂的约束技术</li>
</ol>
</li>
<li><p>DTD：</p>
<ul>
<li>引入dtd文档到xml文档中<ol>
<li>内部dtd：<ul>
<li><code>&lt;!DOCTYPE 根标签名 [dtd文件中具体内容]&gt;</code></li>
</ul>
</li>
<li>外部dtd：<ul>
<li>本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code></li>
<li>外部：<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;随便取个文件名&quot; &quot;dtd文件的位置URL&quot;&gt;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Schema：</p>
<ul>
<li>引入：<ol>
<li>填写xml文档的根元素</li>
<li>引入xsi前缀 xmlns:xsi=”…”</li>
<li>引入xsd文件命名空间 xsi:schemaLocation=”….”</li>
<li>为每一个xsd约束声明一个前缀，作为标识 xmlns:…=”….”</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="解析：操作xml文档，将文档中数据读取到内存中"><a href="#解析：操作xml文档，将文档中数据读取到内存中" class="headerlink" title="解析：操作xml文档，将文档中数据读取到内存中"></a>解析：操作xml文档，将文档中数据读取到内存中</h3><ul>
<li><p>操作xml文档：</p>
<ol>
<li>解析（读取）</li>
<li>写入：将内存中的数据保存到xml文档中，持久化的存储</li>
</ol>
</li>
<li><p>解析xml的方式：</p>
<ol>
<li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<ul>
<li>优点：操作方便，可以对文档进行CRUD的操作</li>
<li>缺点：占内存</li>
</ul>
</li>
<li>SAX：逐行读取，基于事件驱动的<ul>
<li>优点：不占内存</li>
<li>缺点：只能读取不能增删改</li>
</ul>
</li>
</ol>
</li>
<li><p>xml常见的解析器：</p>
<ol>
<li>JAXP：sun公司提供的解析器，支持DOM和SAX</li>
<li>DOM4J：一款非常优秀的解析器，DOM方式</li>
<li>Jsoup：是一款HTML解析器，但是比较好用，也可以用于解析XML，DOM方式</li>
<li>PULL：Andriod操作系统内置的解析器，SAX方式</li>
</ol>
</li>
</ul>
<h3 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h3><ul>
<li><p>快速入门：</p>
<ul>
<li>步骤：<ol>
<li>导入jar包</li>
<li>获取Document对象</li>
<li>获取对应的标签Element对象</li>
<li>获取数据</li>
</ol>
</li>
</ul>
</li>
<li><p>对象的使用：</p>
<ol>
<li><p>Jsoup：工具类，可以解析html文或xml文档，返回Document</p>
<ul>
<li>parse：解析html文或xml文档，返回Document对象<ul>
<li>parse(File in, String charsetName)：解析xml或html文件</li>
<li>parse(String html)：解析xml或html字符串</li>
<li>parse(URL url, int timeoustMillis)：通过网络路径获取指定的html或xml的文档对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Document：文档对象，代表内存中得到DOM树</p>
<ul>
<li>获取Element对象：<ul>
<li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li>
<li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li>
<li>getElementsByAttributeValue(String key，String value)：根据对应的属性名称和属性值获取元素对象集合</li>
<li>getElementsById(String id)：根据id属性值获取唯一Element对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Elements：元素Element对象的集合。可以当做ArrayList&lt; Element&gt;来使用</p>
</li>
<li><p>Element：元素对象</p>
<ol>
<li>获取子元素对象：<ul>
<li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li>
<li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li>
<li>getElementsByAttributeValue(String key，String value)：根据对应的属性名称和属性值获取元素对象集合</li>
<li>getElementsById(String id)：根据id属性值获取唯一Element对象</li>
</ul>
</li>
<li>获取属性值：<ul>
<li>String attr(String key)：根据属性名称获取属性值</li>
</ul>
</li>
<li>获取文本：<ul>
<li>String text()；纯文本内容</li>
<li>String html()：包括子标签的内容</li>
</ul>
</li>
</ol>
</li>
<li><p>Node：节点对象</p>
<ul>
<li>是Document和Element的父类</li>
</ul>
</li>
</ol>
</li>
<li><p>快速查询方式：</p>
<ol>
<li><p>selector：选择器</p>
<ul>
<li>使用的方法：Elements select(String cssQuery)<ul>
<li>语法：参考selector类中定义的语法</li>
</ul>
</li>
</ul>
</li>
<li><p>XPath：XML路径语言，用来确定XML文档中某部分位置的语言</p>
<ul>
<li>使用Jsoup的Xpath需要额外导入jar包</li>
<li>查询XPath语法完成查询</li>
</ul>
</li>
</ol>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XML/" rel="tag">XML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Tomcat" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/05/Tomcat/"
    >Tomcat和Servlet</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/05/Tomcat/" class="article-date">
  <time datetime="2020-05-04T16:00:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>web服务器软件。</p>
<ul>
<li>服务器：安装了服务器软件的计算机。</li>
<li>服务器软件：接收用户请求，处理请求，做出响应。</li>
<li>web服务器软件：接收用户请求，处理请求，做出响应。<ul>
<li>在web服务器软件中可以部署web项目，让用户通过浏览器访问这些项目。</li>
<li>web容器</li>
</ul>
</li>
</ul>
<p>常见的java相关的web服务器软件：</p>
<ul>
<li>webLogic：Oracle公司，大型javaEE服务器，支持所有的javaEE规范，收费。</li>
<li>webSphere：IBM公司，大型javaEE服务器，支持所有的javaEE规范，收费。</li>
<li>JBOSS：JBOSS公司，大型javaEE服务器，支持所有的javaEE规范，收费。</li>
<li>Tomcat：Apache基金组织，中小型javaEE服务器，仅仅支持少量javaEE规范，开源免费。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>部署项目的方式：<ol>
<li>直接将项目放在webapps文件夹下。<ul>
<li>简化部署：将项目打包成一个war包，再将war包放到webapps目录下，war包会自动解压缩。</li>
</ul>
</li>
<li>配置conf/server.xml文件，在&lt; host&gt;标签体中配置<code>&lt;Context docBase=&quot;项目存放路径&quot; path=&quot;/虚拟目录&quot; /&gt;</code></li>
<li>在conf/Catalina/localhost创建任意名称的xml文件，在文件中编写<code>&lt;Context docBase=&quot;项目存放路径&quot; /&gt;</code>，虚拟目录就是xml文件的名称。</li>
</ol>
</li>
</ul>
<h1 id="Servlet简单学习"><a href="#Servlet简单学习" class="headerlink" title="Servlet简单学习"></a>Servlet简单学习</h1><p>运行在服务器端的小程序。</p>
<ul>
<li>Servlet就是一个接口，定义了java类被浏览器访问到(tomcat识别)的规则。</li>
<li>将来我们自定义一个类，实现Servlet接口，复写方法。</li>
</ul>
<h2 id="Servlet快速入门"><a href="#Servlet快速入门" class="headerlink" title="Servlet快速入门"></a>Servlet快速入门</h2><ol>
<li><p>创建javaEE的项目</p>
</li>
<li><p>定义一个类，必须实现Servlet接口</p>
</li>
<li><p>实现接口中的抽象方法</p>
</li>
<li><p>配置Servlet</p>
<ul>
<li><p>web.xml中配置：</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;
    &lt;servlet-class&gt;web.servlet.ServletDemo01&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre></li>
</ul>
</li>
</ol>
<h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><ol>
<li>当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的servlet的资源路径。</li>
<li>查找web.xml文件是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</li>
<li>如果有则在找到对应的<code>&lt;servlet-class&gt;</code>全类名。</li>
<li>tomcat会将字节码文件加载进内存，并且创建其对象。</li>
<li>调用其方法。</li>
</ol>
<h2 id="Servlet的生命周期："><a href="#Servlet的生命周期：" class="headerlink" title="Servlet的生命周期："></a>Servlet的生命周期：</h2><ol>
<li><p>被创建：执行init方法，只执行一次。</p>
<ul>
<li><p>servlet什么时候被创建？</p>
<ul>
<li>默认情况下，第一次访问时，servlet被创建</li>
<li>可以配置执行servlet的创建时机<ul>
<li>在<code>&lt;servlet&gt;</code>标签下配置<ol>
<li>第一次被访问时，创建<ul>
<li><code>&lt;load-on-startup&gt;</code>的值为负数</li>
</ul>
</li>
<li>在服务器启动时，创建<ul>
<li><code>&lt;load-on-startup&gt;</code>的值为0或正数</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>servlet的init方法只执行一次，说明一个servlet在内存中只存在一个对象，servlet是单例的。</p>
<ul>
<li>多个用户同时访问时，可能存在线程安全问题。<ul>
<li>解决：尽量不要在servlet中定义成员变量。即使定义了成员变量，也不要对其修改值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>提供服务：执行service方法，可以执行多次。</p>
<ul>
<li>每次访问servlet时都会执行一次。</li>
</ul>
</li>
<li><p>被销毁：执行destroy方法，只执行一次。</p>
<ul>
<li>servlet被销毁时执行一次，服务器正常关闭时。</li>
</ul>
</li>
</ol>
<h2 id="Servlet3-0及以上："><a href="#Servlet3-0及以上：" class="headerlink" title="Servlet3.0及以上："></a>Servlet3.0及以上：</h2><ul>
<li>好处：<ul>
<li>支持注解配置。可以不需要web.xml。</li>
</ul>
</li>
<li>步骤：<ol>
<li>创建javaEE项目，选择servlet版本3.0以上，可以不创建web.xml。</li>
<li>定义一个类实现Servlet接口。</li>
<li>复写方法。<ol start="4">
<li>在类上使用@WebServlet(“资源路径”)注解进行配置。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Servlet的体系结构："><a href="#Servlet的体系结构：" class="headerlink" title="Servlet的体系结构："></a>Servlet的体系结构：</h2><ul>
<li>Servlet，GenericServlet，HttpServlet<ol>
<li>GenericServlet继承自Servlet，将Servlet接口中除service方法都进行了默认空实现，只将service方法作为抽象方法，定义时只需实现service方法即可。</li>
<li>HttpServlet继承自GenericServlet，是对http协议的一种封装，简化操作。定义时可以复写doGet/doPost方法。</li>
</ol>
</li>
</ul>
<h2 id="Servlet相关配置："><a href="#Servlet相关配置：" class="headerlink" title="Servlet相关配置："></a>Servlet相关配置：</h2><ol>
<li>urlpartten：Servlet访问路径<ol>
<li>一个Servlet可以定义多个访问路径：@WebServlet({“/路径1”，”/路径2”，”/路径3”})。</li>
<li>路径定义规则：<ol>
<li>/xxx</li>
<li>/xxxx/xx/xxx：多层路径，目录结构。</li>
<li>*.后缀名</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="IDEA与Tomcat的相关配置"><a href="#IDEA与Tomcat的相关配置" class="headerlink" title="IDEA与Tomcat的相关配置"></a>IDEA与Tomcat的相关配置</h1><ol>
<li><p>IDEA会为每一个Tomacat部署的项目单独建立一份配置文件。</p>
<ul>
<li>查看控制台的log中的CATALINA_BASE。</li>
</ul>
</li>
<li><p>工作空间项目和Tomacat部署的web项目是两个存在。</p>
<ul>
<li>Tomcat真正访问的是“Tomacat部署的web项目”，“Tomacat部署的web项目”对应着的是“工作空间项目”的web目录下的所有资源。</li>
<li>WEB-INF目录下的资源不能被浏览器直接访问。</li>
<li>断点调试：使用Debug启动而不是Run。</li>
</ul>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-JavaScript" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/01/JavaScript/"
    >JavaScript</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/01/JavaScript/" class="article-date">
  <time datetime="2020-04-30T16:00:00.000Z" itemprop="datePublished">2020-05-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="ECMAScript：客户端脚本语言的标准"><a href="#ECMAScript：客户端脚本语言的标准" class="headerlink" title="ECMAScript：客户端脚本语言的标准"></a>ECMAScript：客户端脚本语言的标准</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><ol>
<li>与html结合方式<ol>
<li>内部js：定义&lt; script&gt;js代码&lt; script/&gt;</li>
<li>外部js：定义&lt; script src属性引入外部js文件&gt;js代码&lt; script/&gt;</li>
</ol>
<ul>
<li><strong>注意：&lt; script&gt;可以定义在html页面的任何地方，但是定义的位置会影响执行的顺序。&lt; script&gt;标签可以定义多个。</strong></li>
</ul>
</li>
<li>注释<ul>
<li>和java中注释规则一样。</li>
</ul>
</li>
<li>数据类型<ol>
<li>原始数据类型：<ol>
<li>number：数字。整数/小数/NaN（not a number 一个不是数字的数字类型）</li>
<li>string：字符串</li>
<li>boolean：true/false</li>
<li>null：空</li>
<li>undefined：未定义。如果一个对象没有给初始化值，则会被默认赋值为undefined</li>
</ol>
</li>
<li>引用数据类型：对象</li>
</ol>
</li>
<li>变量<ul>
<li>Java是强类型语言，而JavaScript是弱类型语言。<ul>
<li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型，只能存储固定的数据类型。</li>
<li>弱类型：在开辟变量存储空间时，不定义空间将来存储的数据的数据类型，可以存放任意的数据类型。</li>
</ul>
</li>
<li>语法：var 变量名=变量值；</li>
</ul>
</li>
<li>运算符<ul>
<li>一元运算符：只有一个运算数的运算符<ul>
<li>++，–，+（正号），-（负号），等</li>
<li><strong>注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。</strong><ul>
<li><strong>其他类型转number：</strong><ul>
<li><strong>string转number，按照字面值转换，如果字面值不是数字，则转为NaN（不是数字的数字）</strong></li>
<li><strong>boolean转number，true转为1，false转为0</strong></li>
<li><strong>其他两种类型转为NaN</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>算数运算符：数学运算<ul>
<li>+，-，*，/，%等</li>
</ul>
</li>
<li>赋值运算符<ul>
<li>=，+=，-=等</li>
</ul>
</li>
<li>比较运算符<ul>
<li>&lt;，&gt;，&gt;=，&lt;=，==，===（全等于）</li>
<li>比较方式：<ol>
<li>类型相同：直接比较。</li>
<li>类型不同：先进行类型转换再进行比较。</li>
</ol>
</li>
<li>===（全等于）：在比较之前，先判断类型，如果类型不一样，则直接返回false。</li>
</ul>
</li>
<li>逻辑运算符<ul>
<li>&amp;&amp;，||，！</li>
<li>其他类型转为boolean类型：<ul>
<li>number：0或NaN为false，其他都是true</li>
<li>string：除了空字符串（“”），其他都是true</li>
<li>null与undefined：都是false</li>
<li>对象：所有对象都为true</li>
</ul>
</li>
</ul>
</li>
<li>三元运算符<ul>
<li>?:表达式</li>
</ul>
</li>
</ul>
</li>
<li>流程控制语句<ul>
<li>if…else…</li>
<li>switch<ul>
<li>在JS中，switch可以接收任意原始数据类型</li>
</ul>
</li>
<li>while</li>
<li>do…while</li>
<li>for</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-基本对象"><a href="#2-基本对象" class="headerlink" title="2.基本对象"></a>2.基本对象</h3><ul>
<li>Function：函数对象<ol>
<li>创建<ol>
<li><code>var fun = new Function(形参列表，方法体)</code></li>
<li><code>function 方法名称(形参列表){方法体}</code></li>
<li><code>var 方法名 = function(形参列表){方法体}</code></li>
</ol>
</li>
<li>方法</li>
<li>属性<ul>
<li>length：代表形参的个数</li>
</ul>
</li>
<li>特点<ol>
<li>方法定义时，形参的类型可以不用写，返回值类型也bu’xie</li>
<li>方法是一个对象，如果定义一个名称相同的方法，会覆盖之前的方法</li>
<li>在JS中，方法的调用只与方法的名称有关，和参数列表无关</li>
<li>在方法声明中有一个隐藏的内置对象（数组），arguments，封装所有的实际参数</li>
</ol>
</li>
<li>调用：<ul>
<li>方法名称(参数列表)；</li>
</ul>
</li>
</ol>
</li>
<li>Array：数组对象<ol>
<li>创建<ol>
<li><code>var arr = new Array(元素列表)；</code></li>
<li><code>var arr = new Array(数组长度)；</code></li>
<li><code>var arr = [元素列表]；</code></li>
</ol>
</li>
<li>方法<ul>
<li>join(参数)：将数组的元素按照指定的分隔符拼接为字符串</li>
<li>push()：向数组中的末尾添加一个元素，并返回新的长度</li>
</ul>
</li>
<li>属性<ul>
<li>length：数组的长度</li>
</ul>
</li>
<li>特点<ol>
<li>JS中，数组元素的类型是可变的</li>
<li>JS中，数组的长度是可变的</li>
</ol>
</li>
</ol>
</li>
<li>Boolean</li>
<li>Date<ol>
<li>创建<ol>
<li><code>var date = new Date()；</code></li>
</ol>
</li>
<li>方法<ul>
<li>toLocalString()：返回本地时间字符串格式</li>
<li>getTime()：获取毫秒值，返回当前日期对象描述的时间到970年1月1日0点的差</li>
</ul>
</li>
<li>属性</li>
<li>特点</li>
</ol>
</li>
<li>Math<ol>
<li>创建<ul>
<li>不用创建，直接使用</li>
</ul>
</li>
<li>方法<ul>
<li>random()：返回0到1之间的随机数，包含0不包含1</li>
<li>cell(x)：向上取整</li>
<li>floor(x)：向下取整</li>
<li>round(x)：四舍五入</li>
</ul>
</li>
<li>属性<ul>
<li>PI：圆周率</li>
</ul>
</li>
<li>特点</li>
</ol>
</li>
<li>Number</li>
<li>String</li>
<li>RegExp：正则表达式对象<ul>
<li>正则表达式：定义字符串的组成规则<ol>
<li>单个字符：[]</li>
</ol>
<ul>
<li>如：[a] [ab] [a-zA-Z0-9_]</li>
<li>特殊符号代表特殊含义的单个字符：<ul>
<li>\d：单个数字字符 [0-9]</li>
<li>\w：单个单词字符 [a-zA-Z0-9_]</li>
</ul>
</li>
</ul>
<ol start="2">
<li>量词符号：<ul>
<li>?：表示出现0次或1次</li>
<li>*：表示出现0次或多次</li>
<li>+：表示出现1次或多次</li>
<li>{m,n}：表示出现次数在m与n之中，包括m和n<ul>
<li>{m,}：至少出现m次</li>
<li>{,n}：至多出现n次</li>
</ul>
</li>
</ul>
</li>
<li>开始结束符号：<ul>
<li>^：开始</li>
<li>$：结束</li>
</ul>
</li>
</ol>
</li>
<li>正则对象<ol>
<li>创建<ul>
<li><code>var reg = new RegExp(&quot;正则表达式&quot;)；</code><ul>
<li><strong>注意：正则表达式中的\应该写两个，因为在双引号中会被转义</strong></li>
</ul>
</li>
<li><code>var reg = /正则表达式/；</code></li>
</ul>
</li>
<li>方法<ul>
<li>test(参数)：验证指定的字符串是否符合正则表达式</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>Global<ol>
<li>特点：全局对象，这个Global对象中封装的方法可以不需要对象就直接调用。 方法名();</li>
<li>方法：<ul>
<li>encodeURI()：url编码</li>
<li>decodeURI()：url解码</li>
<li>encodeURIComponent()：url编码，会进行编码的字符更多</li>
<li>decodeURIComponent()：url解码</li>
<li>parseInt()：将字符串转为数字<ul>
<li>逐一判断每个字符是不是是否是数字，直到不是数字为止，将前变数字部分转换为number</li>
</ul>
</li>
<li>isNaN()：判断一个字符是不是NaN</li>
<li>eval()：将JavaScript字符串，转成脚本来执行</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-BOM对象"><a href="#3-BOM对象" class="headerlink" title="3.BOM对象"></a>3.BOM对象</h3><ul>
<li><p>概念：Browser object Model 浏览器对象模型</p>
<ul>
<li>将浏览器的各个组成部分封装成对象。</li>
</ul>
</li>
<li><p>组成：</p>
<ol>
<li>Window：窗口对象<ul>
<li>创建</li>
<li>方法：<ol>
<li>与弹出框有关的方法<ul>
<li>alert()：显示带有一段消息和一个确认按钮的警告框。</li>
<li>confirm()：显示带有一段信息以及确认按钮和取消按钮的对话框。<ul>
<li>用户点击确认按钮，则返回true</li>
<li>用户点击取消按钮，则返回false</li>
</ul>
</li>
<li>prompt()：显示可提示用户输入的对话框。<ul>
<li>返回值。获取用户输入的值。</li>
</ul>
</li>
</ul>
</li>
<li>与打开关闭有关的方法：<ul>
<li>open()：打开一个新的浏览器窗口</li>
<li>close()：关闭浏览器窗口</li>
</ul>
</li>
<li>与定时器有关的方法<ul>
<li>setTimeout()：在指定的毫秒数后调用函数或计算表达式。<ul>
<li>参数：<ul>
<li>参数1：js代码或者方法对象</li>
<li>参数2：毫秒值</li>
</ul>
</li>
<li>返回值：唯一标识</li>
</ul>
</li>
<li>clearTimeout()：取消由setTimeout()方法设置的timeout。</li>
<li>setInterval()：按照指定的周期（以毫秒计）来调用函数或表达式。<ul>
<li>参数：<ul>
<li>参数1：js代码或者方法对象</li>
<li>参数2：毫秒值</li>
</ul>
</li>
<li>返回值：唯一标识</li>
</ul>
</li>
<li>clearInterval()：取消seItnterval()设置的timeout。</li>
</ul>
</li>
</ol>
</li>
<li>属性<ul>
<li>获取其他BOM对象：<ul>
<li>history</li>
<li>location</li>
<li>Navigator</li>
<li>Screen</li>
</ul>
</li>
<li>获取DOM对象<ul>
<li>document</li>
</ul>
</li>
</ul>
</li>
<li>特点：<ol>
<li>不需要创建，可以直接使用window使用。window.方法名()；</li>
<li>window引用可以省略。方法名()；</li>
</ol>
</li>
</ul>
</li>
<li>Navigator：浏览器对象</li>
<li>Screen：显示器屏幕对象</li>
<li>History：历史记录对象<ul>
<li>创建(获取)<ol>
<li>window.history</li>
<li>history</li>
</ol>
</li>
<li>方法<ul>
<li>back() 加载history列表中的前一个URL</li>
<li>forward() 加载history列表中的下一个URL</li>
<li>go() 加载history列表中的某个具体页面<ul>
<li>参数：<ul>
<li>正数：前进几个历史记录</li>
<li>负数：后退几个历史记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>属性<ul>
<li>length：返回当前窗口历史记录列表中的URL数量</li>
</ul>
</li>
</ul>
</li>
<li>Location：地址栏对象<ol>
<li>创建(获取)<ul>
<li>window.location</li>
<li>location</li>
</ul>
</li>
<li>方法<ul>
<li>reload() 重新加载当前文档。刷新</li>
</ul>
</li>
<li>属性<ul>
<li>href 设置或返回完整的URL</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-DOM对象"><a href="#4-DOM对象" class="headerlink" title="4.DOM对象"></a>4.DOM对象</h3><ul>
<li><p>概念：Document Object Model 文档对象模型</p>
<ul>
<li>将标记语言文档的各个组成部分封装为对象。可以使用这些个对象，对标记语言文档进行CRUD的动态操作。</li>
</ul>
</li>
<li><p>功能：控制html文档的内容</p>
</li>
<li><p>W3C DOM标准被分为3个不同的部分</p>
<ul>
<li>核心DOM：针对任何结构化文档的标准模型<ul>
<li>Document对象：文档对象</li>
<li>Element：元素对象</li>
<li>Attribute：属性对象</li>
<li>Text：文本对象</li>
<li>Comment：注释对象</li>
<li>Node：节点对象，其他五个的父对象</li>
</ul>
</li>
<li>XML DOM：针对XML文档的标准模型</li>
<li>HTML DOM：针对HTML文档的标准模型</li>
</ul>
</li>
<li><p>核心DOM模型：</p>
<ul>
<li>Document对象：文档对象<ol>
<li>创建(获取)：在htnl模型中可以使用window对象来获取<ol>
<li>window.document</li>
<li>document</li>
</ol>
</li>
<li>方法：<ul>
<li>获取Element对象：<ul>
<li>getElementById() 根据id属性值获取元素对象。</li>
<li>getElementsByTagName() 根据元素名称获取元素对象们，返回值是一个数组</li>
<li>getElementsByClassName() 根据class的属性值来获取元素对象们</li>
<li>getElementsByName() 根据Name属性值获取元素对象们</li>
</ul>
</li>
<li>创建其他DOM对象：<ul>
<li>createAttribute(Name)</li>
<li>createComment()</li>
<li>createElement()</li>
<li>createTextNode()</li>
</ul>
</li>
</ul>
</li>
<li>属性：<ul>
<li>parentNode：获取父节点</li>
</ul>
</li>
</ol>
</li>
<li>Element：元素对象<ol>
<li>获取：通过Document对象来获取和创建</li>
<li>方法：<ul>
<li>removeAttribute()：删除属性</li>
<li>setAttribute()：设置属性</li>
</ul>
</li>
</ol>
</li>
<li>Node：节点对象，其他五个的父对象<ul>
<li>特点：所有DOM对象都可以被认为是一个节点</li>
<li>方法：<ul>
<li>COUR DOM树：<ul>
<li>appendChild()：向节点的子节点列表的结尾添加新的子节点。</li>
<li>removeChild()：删除(并返回)当前节点的指定子节点。</li>
<li>replaceChild()：用新的节点替换一个子节点</li>
</ul>
</li>
</ul>
</li>
<li>属性：</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>HTML DOM</li>
</ul>
<ol>
<li><p>标签体的设置和获取：innerHTML</p>
</li>
<li><p>使用html元素对象的属性：查询API文档</p>
</li>
<li><p>控制元素样式：</p>
<ol>
<li>使用元素的style属性来设置</li>
<li>提前定义好类选择器的样式，通过元素的className属性来设置类属性值。</li>
</ol>
</li>
</ol>
<ul>
<li><p>操作Element对象</p>
<ol>
<li>修改属性值<ol>
<li>明确获取的对象是哪一个？</li>
<li>查看API文档，看其中有哪些属性值可以设置</li>
</ol>
</li>
<li>修改标签体内容<ul>
<li>属性：innerHTML</li>
</ul>
</li>
</ol>
</li>
<li><p>事件简单学习</p>
<ul>
<li>功能：某些组件被执行了某些操作后触发某些代码的执行</li>
<li>如何绑定事件：<ol>
<li>直接在html标签上，指定事件的属性，属性值就是js代码</li>
<li>通过js获取元素对象，指定事件属性</li>
</ol>
</li>
</ul>
</li>
<li><p>事件</p>
<ul>
<li>常见的事件：<ol>
<li>点击事件：<ol>
<li>onclick：当用户点击某个对象时调用的事件句柄。</li>
<li>ondblclick：双击事件</li>
</ol>
</li>
<li>焦点事件：<ol>
<li>onblur：失去焦点<ul>
<li>可以用于表单验证</li>
</ul>
</li>
<li>onfocus：元素获得焦点</li>
</ol>
</li>
<li>加载事件：<ol>
<li>onload：一张页面或一张图片完成加载</li>
</ol>
</li>
<li>鼠标事件：<ol>
<li>onmousedown：鼠标按钮被按下<ul>
<li>定义方法时，定义一个形参，接受event对象</li>
<li>event对象的button属性可以获取哪个鼠标按钮键被点击了</li>
</ul>
</li>
<li>onmouseup：鼠标按键被松开</li>
<li>onmousemove：鼠标被移动</li>
<li>onmouseover：鼠标移到某元素之上</li>
<li>onmouseout：鼠标从某元素移开</li>
</ol>
</li>
<li>键盘事件：<ol>
<li>onkeydown：键盘某个按键被按下</li>
<li>onkeyup：键盘某个按键被松开</li>
<li>onkeypress：键盘按下并松开</li>
</ol>
</li>
<li>选中和改变：<ol>
<li>onchange：域的内容被改变</li>
<li>onselect：文本被选中</li>
</ol>
</li>
<li>表单事件：<ol>
<li>onsubmit：确认按钮被点击<ul>
<li>可以阻止表单的提交，方法返回true则提交，返回false则不提交</li>
</ul>
</li>
<li>onreset：重置按钮被点击</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-CSS" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/01/CSS/"
    >CSS</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/01/CSS/" class="article-date">
  <time datetime="2020-04-30T16:00:00.000Z" itemprop="datePublished">2020-05-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>页面美化和布局控制</p>
<ul>
<li><p>概念：Cascading Style Sheets 层叠样式表</p>
<ul>
<li>层叠：多个样式可以作用在同一个html的元素上，同时生效</li>
</ul>
</li>
<li><p>好处</p>
<ol>
<li>功能强大</li>
<li>将内容的展示和样式控制分离<ul>
<li>降低耦合度</li>
<li>让分工协作更容易</li>
<li>提高开发效率</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="CSS的使用：CSS与html结合方式"><a href="#CSS的使用：CSS与html结合方式" class="headerlink" title="CSS的使用：CSS与html结合方式"></a>CSS的使用：CSS与html结合方式</h2><ol>
<li><p>内联样式：在标签内使用style属性指定css代码</p>
<ul>
<li>如：&lt; div style=”color:red;”&gt;hello&lt; /div&gt;</li>
</ul>
</li>
<li><p>内部样式：在head标签内，定义style标签，style标签的内容就是css代码</p>
<ul>
<li><p>如</p>
<pre><code>&lt;head&gt;
    &lt;style&gt;
        div{
            color:blue;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;div&gt;hello&lt;/div&gt;</code></pre></li>
</ul>
</li>
<li><p>外部样式:定义css资源文件，在head标签内，定义link标签，引入外部资源文件。</p>
</li>
</ol>
<ul>
<li><p>如</p>
<pre><code>&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;
&lt;/head&gt;

&lt;div&gt;hello&lt;/div&gt;</code></pre></li>
</ul>
<h2 id="CSS基本语法"><a href="#CSS基本语法" class="headerlink" title="CSS基本语法"></a>CSS基本语法</h2><ul>
<li><p>格式：</p>
<pre><code>选择器{
    属性名1：属性值1；
    属性名2：属性值2；
    .....
}</code></pre></li>
<li><p>选择器：筛选具有相似特征的元素</p>
</li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul>
<li><p>分类：</p>
<ol>
<li><p>基础选择器</p>
<ol>
<li>id选择器：选择具体的id属性值的元素。<ul>
<li>语法：#id属性值{}</li>
<li><strong>优先级最高</strong></li>
</ul>
</li>
<li>元素选择器：选择具有相同标签名称的元素。<ul>
<li>语法：标签名称{}</li>
<li><strong>优先级低于id选择器和类选择器</strong></li>
</ul>
</li>
<li>类选择器：选择具有相同的class属性值的元素。<ul>
<li>语法：.class属性值{}</li>
<li><strong>优先级低于id选择器</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>扩展选择器</p>
<ol>
<li>*：表示选择所有元素<ul>
<li>语法：*{}</li>
</ul>
</li>
<li>并集选择器：筛选选择器1下和选择器2共有的元素<ul>
<li>语法：选择器1，选择器2{}</li>
</ul>
</li>
<li>子选择器：筛选选择器1下的选择器2的元素<ul>
<li>语法：选择器1 选择器2{}</li>
</ul>
</li>
<li>父选择器：：筛选选择器2的父元素选择器1<ul>
<li>语法：选择器1&gt;选择器2{}</li>
</ul>
</li>
<li>属性选择器：选择元素名称，属性名=属性值的元素<ul>
<li>语法：元素名称[ 属性名=”属性值” ]{}</li>
</ul>
</li>
<li>伪类选择器：选择一些元素所具有的状态<ul>
<li>语法：元素:状态{}</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li><p>字体、文本</p>
<ul>
<li>font-size：字体大小</li>
<li>color：文本颜色</li>
<li>text-align：文本对齐方式</li>
<li>line-height：行高</li>
</ul>
</li>
<li><p>背景</p>
<ul>
<li>background：复合属性。</li>
</ul>
</li>
<li><p>边框</p>
<ul>
<li>border：设置边框，复合属性。</li>
</ul>
</li>
<li><p>尺寸</p>
<ul>
<li>width：宽度</li>
<li>height：高度</li>
</ul>
</li>
<li><p>盒子模型：控制布局</p>
<ul>
<li>margin：外边距</li>
<li>padding：内边距<ul>
<li>默认情况下内边距会影响整个盒子的大小，可以使用box-sizing：boder-box，让width和height就是盒子最终大小。</li>
</ul>
</li>
<li>float：浮动</li>
</ul>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-ConnPool" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/28/ConnPool/"
    >数据库连接池</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/28/ConnPool/" class="article-date">
  <time datetime="2020-04-27T16:00:00.000Z" itemprop="datePublished">2020-04-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><ul>
<li><p><strong>概念：</strong> 其实就是一个容器（集合），存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
</li>
<li><p><strong>好处：</strong> </p>
<ol>
<li>节约资源</li>
<li>用户访问高效</li>
</ol>
</li>
<li><p><strong>实现：</strong></p>
<ol>
<li><p>标准接口：DataSource</p>
<ol>
<li>方法：<ul>
<li>获取连接：getConnection()</li>
<li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了，而是归还连接。</li>
</ul>
</li>
</ol>
</li>
<li><p>一般我们不去实现它，有数据库厂商来实现</p>
<ol>
<li>C3P0：数据库连接池技术。</li>
<li>Druid：数据库连接池技术，由阿里巴巴提供。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="C3P0：数据库连接池技术"><a href="#C3P0：数据库连接池技术" class="headerlink" title="C3P0：数据库连接池技术"></a>C3P0：数据库连接池技术</h2><ul>
<li>步骤：<ol>
<li>导入jar包（两个） c3p0-0.9.5.5-sources.jar和mchange-commons-java-0.2.19-sources.jar</li>
<li>定义配置文件：<ul>
<li>名称：c3p0.properties或者c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可</li>
</ul>
</li>
<li>创建核心对象：数据库连接池对象 ComboPooledDataSource</li>
<li>获取连接：getConnection</li>
</ol>
</li>
</ul>
<h2 id="Druid：数据库连接池技术，由阿里巴巴提供"><a href="#Druid：数据库连接池技术，由阿里巴巴提供" class="headerlink" title="Druid：数据库连接池技术，由阿里巴巴提供"></a>Druid：数据库连接池技术，由阿里巴巴提供</h2><ul>
<li><p>步骤：</p>
<ol>
<li>导入jar包 druid-1.1.22.jar</li>
<li>定义配置文件：<ul>
<li>是properties形式的</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>获取数据库连接池对象：加载配置文件，然后通过工厂来获取 DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
</li>
<li><p>定义工具类</p>
<ol>
<li>定义一个类 JDBCUtils</li>
<li>提供静态代码块加载配置文件，初始化连接池对象</li>
<li>提供方法：<ol>
<li>获取连接方法：通过数据库连接池获取连接</li>
<li>释放资源</li>
<li>获取连接池对象的方法</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>代码实现示例</strong></p>
<pre><code>    public class JDBCUtils {

    private static DataSource ds;

    //数据库连接池的初始化
    static {
        try {
            Properties prop = new Properties();
            prop.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
            ds = DruidDataSourceFactory.createDataSource(prop);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //获取连接的方法
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }

    //释放资源的方法
    public static void close(Connection conn, Statement st, ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
        if (st != null) {
            try {
                st.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }

    //释放资源的方法
    public static void close(Connection conn, Statement st) {
        close(conn, st, null);
    }

    //获取连接池对象的方法
    public static DataSource getDataSource() {
        return ds;
    }

}</code></pre></li>
</ul>
<h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><ul>
<li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发。</p>
</li>
<li><p>步骤：</p>
<ol>
<li>导入jar包。</li>
<li>创建JDBCTemplate对象。依赖于数据源DataSource。</li>
<li>调用DBCTemplate来完成增删改查的操作。<ul>
<li>update()：执行DML语句。</li>
<li>queryForMap()：查询结果将结果集封装为Map集合，将一条记录封装为Map集合。<ul>
<li>注意：这个方法查询的结果集长度只能是1。</li>
</ul>
</li>
<li>queryForList()：查询结果将结果集封装为List集合。<ul>
<li>注意：将每一条记录封装为Map集合，再将map集合装载到List集合中。</li>
</ul>
</li>
<li>query()：查询结果将结果封装为JavaBean对象。<ul>
<li>参数：RowMapper<ul>
<li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li>
<li>new BeanPropertyRowMapper&lt;类型&gt;（类型.class）</li>
</ul>
</li>
</ul>
</li>
<li>queryForObject()：查询结果将结果封装为对象。<ul>
<li>一般用于聚合函数的查询。</li>
<li>queryForObject(sql语句, 返回值类型.class);</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-HTML" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/28/HTML/"
    >HTML</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/28/HTML/" class="article-date">
  <time datetime="2020-04-27T16:00:00.000Z" itemprop="datePublished">2020-04-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTML/">HTML</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul>
<li>概念：是最基础的网页开发语言<ul>
<li>Hyper Text Markup Language 超文本标记语言<ul>
<li>超文本：超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。</li>
<li>标记语言：由标签构成的语言。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="几类标签的学习"><a href="#几类标签的学习" class="headerlink" title="几类标签的学习"></a>几类标签的学习</h2><h3 id="1-文件标签：构成html最基本的标签"><a href="#1-文件标签：构成html最基本的标签" class="headerlink" title="1.文件标签：构成html最基本的标签"></a>1.文件标签：构成html最基本的标签</h3><ul>
<li>htlm：html文档的根标签。</li>
<li>head：头标签。用于指定html文档的一些属性。引入外部的资源。</li>
<li>title：标题标签。</li>
<li>body：体标签。</li>
<li>&lt; !DOCTYPE html &gt; ：html5中定义该文档是html文档。</li>
</ul>
<h3 id="2-文本标签：和文本有关的标签"><a href="#2-文本标签：和文本有关的标签" class="headerlink" title="2.文本标签：和文本有关的标签"></a>2.文本标签：和文本有关的标签</h3><ul>
<li><p>注释：&lt; !–注释内容–&gt;</p>
</li>
<li><p>&lt; h1&gt; to &lt; h6&gt;：标题标签</p>
</li>
<li><p>&lt; p&gt;：段落标签</p>
</li>
<li><p>&lt; br&gt;：换行</p>
</li>
<li><p>&lt; hr&gt;：显示一条水平线</p>
</li>
<li><p>&lt; b&gt;：粗体</p>
</li>
<li><p>&lt; i&gt;：斜体</p>
</li>
<li><p>&lt; center&gt;：文本居中</p>
</li>
<li><p>&lt; font&gt;：字体标签(HTML5不再支持)</p>
<ul>
<li>color：颜色</li>
<li>size：大小</li>
<li>face：字体</li>
</ul>
</li>
<li><p>属性定义：(HTML5中也推荐不再支持)</p>
<ul>
<li>color：<ol>
<li>英文单词定义</li>
<li>rgb(值1，值2，值3)</li>
<li>#值1值2值3，值为十六进制</li>
</ol>
</li>
<li>width：<ol>
<li>数值：width=’20’，数值单位默认是px(像素)</li>
<li>%数值：表示相对于父元素的占比</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-图片标签"><a href="#3-图片标签" class="headerlink" title="3.图片标签"></a>3.图片标签</h3><ul>
<li>&lt; img&gt;：展示一张图片<ul>
<li>以./开头的路径表示以当前目录开始</li>
<li>以../开头的路径表示退回上一层路径</li>
</ul>
</li>
</ul>
<h3 id="4-列表标签"><a href="#4-列表标签" class="headerlink" title="4.列表标签"></a>4.列表标签</h3><ul>
<li>有序列表<ul>
<li>&lt; ol&gt;</li>
<li>&lt; li&gt;</li>
</ul>
</li>
<li>无序列表<ul>
<li>&lt; ul&gt;</li>
<li>&lt; li&gt;</li>
</ul>
</li>
</ul>
<h3 id="5-链接标签"><a href="#5-链接标签" class="headerlink" title="5.链接标签"></a>5.链接标签</h3><ul>
<li>&lt; a&gt;：定义一个超链接<ul>
<li>属性：<ul>
<li>href：指定访问资源的URL</li>
<li>target：<ul>
<li>_blank    在新窗口中打开被链接文档。</li>
<li>_self    默认。在相同的框架中打开被链接文档。</li>
<li>_parent    在父框架集中打开被链接文档。</li>
<li>_top    在整个窗口中打开被链接文档。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-表格标签"><a href="#6-表格标签" class="headerlink" title="6.表格标签"></a>6.表格标签</h3><ul>
<li>&lt; table&gt;：定义表格<ul>
<li>width：宽度</li>
<li>border：边框</li>
<li>cellpadding：定义内容和单元格的距离。</li>
<li>cellspacing：定义单元格之间的距离，如果为0，则边框线合为一体只有一条。</li>
<li>bgcolor：背景色</li>
</ul>
</li>
<li>&lt; td&gt;：定义单元格<ul>
<li>colspan：合并列</li>
<li>rowspan：合并行</li>
</ul>
</li>
<li>&lt; tr&gt;：定义行</li>
<li>&lt; th&gt;：定义表头单元格</li>
<li>&lt; caption&gt;：表格标题</li>
<li>&lt; thead&gt;：表示表格的头部分</li>
<li>&lt; tbody&gt;：表示表格的体部分</li>
<li>&lt; tfoot&gt;：表示表格的脚部分</li>
</ul>
<h3 id="7-div和span标签"><a href="#7-div和span标签" class="headerlink" title="7.div和span标签"></a>7.div和span标签</h3><ul>
<li>&lt; span&gt;:文本信息在一行展示，行内标签，内联标签。</li>
<li>&lt; div&gt;:每一个div占满一整行。块级标签。</li>
</ul>
<h3 id="8-语义化标签"><a href="#8-语义化标签" class="headerlink" title="8.语义化标签"></a>8.语义化标签</h3><p>html5中为了提高程序的可读性，提供了一些标签。</p>
<ul>
<li>&lt; header&gt;</li>
<li>&lt; footer&gt;</li>
<li>……</li>
</ul>
<h3 id="9-表单标签"><a href="#9-表单标签" class="headerlink" title="9.表单标签"></a>9.表单标签</h3><ul>
<li><p>表单：用于采集用户输入的数据的。用于和服务器进行交互。</p>
</li>
<li><p>&lt; form&gt;：表单标签</p>
<ul>
<li><p>属性：</p>
<ul>
<li>action：指定提交数据的URL</li>
<li>method：指定提交方式<ul>
<li>分类：一共七种，常用的有两种<ul>
<li>get：请求参数会在地址栏中显示。请求参数的长度有限制。不太安全。</li>
<li>post：请求参数不会在地址栏中显示。会封装在请求体中。请求参数长度没有限制。较为安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表单项中的数据想要被提交，必须指定其name属性</p>
</li>
</ul>
</li>
<li><p>表单项标签</p>
<ul>
<li><p>&lt; input&gt;：可以通过type属性值，改变元素展示的样子</p>
<ul>
<li><p>type属性：</p>
<ul>
<li>text；文本输入框(默认值)<ul>
<li>placeholder：指定输入框的提示信息，当有输入时，清空提示信息。</li>
</ul>
</li>
<li>password：密码输入框</li>
<li>radio：单选框<ul>
<li><strong>注意：</strong><ol>
<li>让多个单选框实现单选的效果，则多个单选框的name值必须一样。</li>
<li>一般会给每一个单选框提供value值，指定其被选中后提交的值。</li>
<li>checked属性可以指定默认选中的值。</li>
</ol>
</li>
</ul>
</li>
<li>checkbox：复选框<ul>
<li><strong>注意：</strong><ol>
<li>一般会给每一个单选框提供value值，指定其被选中后提交的值。</li>
<li>checked属性可以指定默认选中的值。</li>
</ol>
</li>
</ul>
</li>
<li>file：文件选择框</li>
<li>hidden：隐藏域，用于提交一些信息</li>
<li>submit：提交按钮</li>
<li>button：普通按钮</li>
<li>image：图片提交按钮，通过src指定图片路径</li>
</ul>
</li>
<li><p>&lt; label&gt;：指定输入项的文字描述信息</p>
<ul>
<li>label的for属性，一般会和input的id属性对应，点击label区域，会让input输入框获得焦点。</li>
</ul>
</li>
</ul>
</li>
<li><p>&lt; select&gt;：下拉列表</p>
<ul>
<li>子元素：&lt; option&gt;：指定列表项</li>
</ul>
</li>
<li><p>textarea：文本域</p>
<ul>
<li>cows：指定列数</li>
<li>rows：指定行数</li>
</ul>
</li>
</ul>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-JDBC" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/27/JDBC/"
    >JDBC</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/27/JDBC/" class="article-date">
  <time datetime="2020-04-26T16:00:00.000Z" itemprop="datePublished">2020-04-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JDBC/">JDBC</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><ul>
<li><p><strong>概念：</strong> Java DataBase Connectivity Java 数据库连接，Java语言操作数据库。</p>
</li>
<li><p><strong>JDBC本质：</strong> 其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
</li>
</ul>
<h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h2><ul>
<li>步骤：<ol>
<li>导入驱动jar包<ol>
<li>复制mysql-connector-java-8.0.20.jar到项目中自己创建的文件夹下，用于存放各种所需要用到的jar包的文件夹。</li>
<li>右键 –&gt; Add As Library</li>
</ol>
</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection<ul>
<li><strong>注意：新版本的jdbc需要在url后边加上?serverTimezone=GMT，否则会报错，因为数据库和系统时区差异。</strong></li>
</ul>
</li>
<li>定义sql</li>
<li>获取执行sql语句执行对象 Statement</li>
<li>执行sql，接收返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-详解各个对象"><a href="#2-详解各个对象" class="headerlink" title="2.详解各个对象"></a>2.详解各个对象</h2><h3 id="1-DriverManager：驱动管理对象"><a href="#1-DriverManager：驱动管理对象" class="headerlink" title="1.DriverManager：驱动管理对象"></a>1.DriverManager：驱动管理对象</h3><ul>
<li><p>功能</p>
<ol>
<li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar包</p>
<ul>
<li><p><code>static void registerDriver​(Driver driver)</code> 使用 DriverManager注册给定的驱动程序。</p>
</li>
<li><p>写代码使用：<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></p>
</li>
<li><p>通过查看源码发现，com.mysql.cj.jdbc.Driver类中包含一个静态代码块，其中静态代码块包含的内容中就是<code>static void registerDriver​(Driver driver)</code>。</p>
</li>
<li><p><strong>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</strong></p>
</li>
</ul>
</li>
<li><p>获取数据库连接</p>
<ul>
<li>方法：<code>static Connection getConnection​(String url, String user, String password)</code></li>
<li>参数：<ul>
<li>url：指定连接的路径<ul>
<li>语法：jdbc:mysql://ip地址（域名）:端口号/数据库名称?serverTimezone=GMT</li>
<li><strong>如果连接的是本机的一个mysql服务器，并且mysql服务的端口默认是3306，则这个url的ip和端口可以不写。</strong></li>
</ul>
</li>
<li>user：用户名</li>
<li>password：密码</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-Connection：数据库连接对象"><a href="#2-Connection：数据库连接对象" class="headerlink" title="2.Connection：数据库连接对象"></a>2.Connection：数据库连接对象</h3><ul>
<li><p>功能</p>
<ol>
<li><p>获取执行sql的对象</p>
<ul>
<li><code>Statement createStatement​()</code></li>
<li><code>PreparedStatement prepareStatement​(String sql)</code></li>
</ul>
</li>
<li><p>管理事务</p>
<ul>
<li>开启事务 <code>void setAutoCommit​(boolean autoCommit)</code> 参数为false，则为开启事务。</li>
<li>提交事务 <code>void commit​()</code></li>
<li>回滚事务 <code>void rollback​()</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-Statement：执行sql的对象"><a href="#3-Statement：执行sql的对象" class="headerlink" title="3.Statement：执行sql的对象"></a>3.Statement：执行sql的对象</h3><ul>
<li>功能：执行sql<ol>
<li><code>boolean execute​(String sql)</code> 可以执行任意sql语句。</li>
<li><code>int executeUpdate​(String sql)</code> 可以执行DML（insert，update，delete）与DDL（create，alter，drop）语句。<ul>
<li>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功，返回值大于0则执行成功，反之，失败。</li>
</ul>
</li>
<li><code>ResultSet executeQuery​(String sql)</code> 可以执行DQL（select）语句。</li>
</ol>
</li>
</ul>
<h3 id="4-ResultSet：结果集对象"><a href="#4-ResultSet：结果集对象" class="headerlink" title="4.ResultSet：结果集对象"></a>4.ResultSet：结果集对象</h3><ul>
<li>boolean next()：游标向下移动一行。</li>
<li>getXxx(参数)：获取数据。<ul>
<li>Xxx：代表数据类型</li>
<li>参数：<ol>
<li>int：代表列的编号，从1开始。</li>
<li>String：代表列名称。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="5-PreparedStatement：执行sql的对象，功能比Statement更强大"><a href="#5-PreparedStatement：执行sql的对象，功能比Statement更强大" class="headerlink" title="5.PreparedStatement：执行sql的对象，功能比Statement更强大"></a>5.PreparedStatement：执行sql的对象，功能比Statement更强大</h3><ol>
<li><p>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题。</p>
<ol>
<li>输入用户名随便，输入密码：a’ or “a” = ‘a</li>
<li>sql: select * from user where username=’dsadsdcz’ and password=’a’ or ‘a’=’a’;</li>
</ol>
</li>
<li><p>解决SQL注入问题：使用PreparedStatement对象来解决。</p>
</li>
<li><p>预编译的SQL：参数使用？作为占位符。</p>
</li>
<li><p>步骤</p>
<ol>
<li>导入驱动jar包</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql<ul>
<li><strong>注意：sql的参数使用？作为占位符。如<code>select * from user where username=? and password=?;</code></strong></li>
</ul>
</li>
<li>获取执行sql语句的对象PreparedStatement。<code>Connection.PreparedStatement(String sql)</code></li>
<li>给？赋值<ul>
<li>方法：setXxx(参数1，参数2)<ul>
<li>参数1：？的位置编号，从1开始。</li>
<li>参数2：？的值。</li>
</ul>
</li>
</ul>
</li>
<li>执行sql，接收返回结果，不需要传递sql语句</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
</ol>
<ul>
<li><strong>注意：后期都会使用PreparedStatement来完成增删改查的所有操作。因为可以防止SQL注入而且效率更高。</strong></li>
</ul>
<hr>
<h2 id="JDBC工具类：JDBCUtils"><a href="#JDBC工具类：JDBCUtils" class="headerlink" title="JDBC工具类：JDBCUtils"></a>JDBC工具类：JDBCUtils</h2><ul>
<li>目的：简化书写</li>
<li>分析：<ol>
<li>注册驱动。</li>
<li>抽取一个方法获取连接对象。</li>
<li>抽取一个方法释放资源。<ul>
<li>可以不用传递参数，还能保证工具类的通用性，可以使用一个properties配置文件。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="代码实现示例："><a href="#代码实现示例：" class="headerlink" title="代码实现示例："></a>代码实现示例：</h3><ol>
<li><p>properties配置文件：</p>
<pre><code>url= jdbc:mysql://localhost:3306/db2?serverTimezone=GMT
user=root
password=000000
driver=com.mysql.cj.jdbc.Driver</code></pre></li>
<li><p>代码</p>
<pre><code>public class JDBCUtils {

private static String url = null;
private static String user = null;
private static String password = null;
private static String driver = null;

//静态代码块，只执行一次，用于注册驱动和变量的初始化
static {
    try {
        Properties prop = new Properties();
        ClassLoader classLoader = JDBCUtils.class.getClassLoader();
        URL res = classLoader.getResource(&quot;jdbc.properties&quot;);
        String path = res.getPath();
        // 因为我的路径中存在中文，所以需要对其进行编码的处理
        path = URLDecoder.decode(path, StandardCharsets.UTF_8);
        System.out.println(path);
        prop.load(new FileReader(path));
        url = prop.getProperty(&quot;url&quot;);
        user = prop.getProperty(&quot;user&quot;);
        password = prop.getProperty(&quot;password&quot;);
        driver = prop.getProperty(&quot;driver&quot;);
        Class.forName(driver);
    } catch (IOException | ClassNotFoundException e) {
        e.printStackTrace();
    }
}

/**
* 获取连接的方法
* @return Connection对象
* @throws SQLException
*/
public static Connection getConnection() throws SQLException {
    return DriverManager.getConnection(url, user, password);
}

/**
* 资源释放
* @param st
* @param conn
*/
public static void close(Statement st, Connection conn) {
    if (st != null) {
        try {
            st.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
    if (conn != null) {
        try {
            conn.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
}

/**
* 资源释放
* @param st
* @param conn
* @param rs
*/
public static void close(Statement st, Connection conn, ResultSet rs) {
    if (rs != null) {
        try {
            rs.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
    if (st != null) {
        try {
            st.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
    if (conn != null) {
        try {
            conn.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
} 
}</code></pre></li>
</ol>
<hr>
<h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><ol>
<li>使用Connection对象来管理事务<ul>
<li>开启事务 <code>void setAutoCommit​(boolean autoCommit)</code> 参数为false，则为开启事务。在sql执行前开启。</li>
<li>提交事务 <code>void commit​()</code>当所有sql执行完提交事务。</li>
<li>回滚事务 <code>void rollback​()</code>在catch中回滚事务。</li>
</ul>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDBC/" rel="tag">JDBC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-SQLkwl" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/24/SQLkwl/"
    >SQL小知识杂谈</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/24/SQLkwl/" class="article-date">
  <time datetime="2020-04-23T16:00:00.000Z" itemprop="datePublished">2020-04-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/SQL%E7%9F%A5%E8%AF%86/">SQL知识</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="SQL的一些小知识"><a href="#SQL的一些小知识" class="headerlink" title="SQL的一些小知识"></a>SQL的一些小知识</h1><hr>
<h2 id="多表关系的实现"><a href="#多表关系的实现" class="headerlink" title="多表关系的实现"></a>多表关系的实现</h2><ol>
<li><p><strong>一对多（多对一）</strong></p>
<ul>
<li>实现方式：在多的一方建立外键，指向一的一方的主键。</li>
</ul>
</li>
<li><p><strong>多对多</strong></p>
<ul>
<li><p>实现方式：需要借助第三张中间表，中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。</p>
</li>
<li><p><em>联合主键：中间表的主键可以是指向另两张表主键的两个外键的联合。例：PRIMARY KEY(rid,uid)；*</em></p>
</li>
</ul>
</li>
<li><p><strong>一对一</strong></p>
<ul>
<li>实现方式：可以在任意一方添加唯一外键指向另一方的主键（一对一关系不常用，如果是一对一，为何不把两张表拼在一起呢）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><p>范式就是设计数据库时需要遵循的一些规范。</p>
<p>范式有<strong>六种</strong>范式：第一范式（1NF），第二范式（2NF），第三范式（3NF），巴斯-科德范式（BCNF），第四范式（4NF），第五范式（5NF，又称完美范式）。</p>
<p><strong>各种范式呈递次规范，越高的范式，数据库冗余越小。一般设计数据库时满足前三范式就可以了。</strong></p>
<h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>每一列都是不可分割的原子数据项。</p>
<h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）。</p>
<p><strong>就是消除部分依赖。</strong></p>
<ul>
<li><p>几个概念</p>
<ol>
<li><p><strong>函数依赖：</strong>A –&gt;B,如果通过A属性（属性组）的值，可以确定唯一B属性的值，则B依赖于A。</p>
<ul>
<li>例：学号 –&gt;姓名   （学号，课程名称） –&gt;分数</li>
</ul>
</li>
<li><p><strong>完全函数依赖：</strong>A –&gt;B,如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。</p>
<ul>
<li>例：（学号，课程名称） –&gt;分数</li>
</ul>
</li>
<li><p><strong>部分函数依赖：</strong>A –&gt;B,如果A是一个属性组，则B属性值的确定需要依赖于A属性组中某一些属性值即可。</p>
<ul>
<li>例：（学号，课程名称） –&gt;姓名</li>
</ul>
</li>
<li><p><strong>传递函数依赖：</strong>A –&gt;B, B –&gt;C，如果通过A属性（属性组）的值，可以确定唯一B属性的值，再通过B属性的值可以确定唯一C属性的值，则称C传递函数依赖于A。</p>
<ul>
<li>例：学号 –&gt;姓名，姓名 –&gt;系主任</li>
</ul>
</li>
<li><p><strong>码：</strong>如果在一张表中，一个属性或属性组，被其他所有属性完全依赖，则称这个属性（属性组）为该表的码。</p>
<ul>
<li>例：（学号，课程名称）</li>
<li>主属性：码属性组中的所有属性</li>
<li>非主属性：去除码属性组中的属性</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。</p>
<p><strong>就是消除传递依赖。</strong></p>
<hr>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="1-内连接查询"><a href="#1-内连接查询" class="headerlink" title="1.内连接查询"></a>1.内连接查询</h3><ol>
<li><p>隐式内连接：使用WHERE条件消除无用数据</p>
<ul>
<li>例：SELECT * FROM emp,dept WHERE emp.id=dept.id;</li>
</ul>
</li>
<li><p>显式内连接：</p>
<ul>
<li>语法<ul>
<li><code>SELECT 字段列表 FROM 表名1 [INNER] JOIN 表名2 ON 条件列表；</code></li>
</ul>
</li>
</ul>
</li>
<li><p>内连接查询：</p>
<ol>
<li>从哪些表中查数据。</li>
<li>条件是什么。</li>
<li>查询哪些字段。</li>
</ol>
</li>
</ol>
<h3 id="2-外连接查询"><a href="#2-外连接查询" class="headerlink" title="2.外连接查询"></a>2.外连接查询</h3><ol>
<li><p>左外连接：</p>
<ul>
<li><p>语法：<code>SELECT 字段名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件列表；</code></p>
</li>
<li><p>查询的是左表（表名1的表）所有数据以及其符合查询条件的交集部分。</p>
</li>
</ul>
</li>
<li><p>右外连接：</p>
<ul>
<li><p>语法：<code>SELECT 字段名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件列表；</code></p>
</li>
<li><p>查询的是右表（表名2的表）所有数据以及其符合查询条件的交集部分。</p>
</li>
</ul>
</li>
</ol>
<h3 id="3-子查询"><a href="#3-子查询" class="headerlink" title="3.子查询"></a>3.子查询</h3><p>就是查询中嵌套查询，被嵌套的查询称为子查询。<br>例：</p>
<pre><code>1. SELECT MAX(salary) FROM emp;
2. SELECT * FROM emp WHERE salary = 9000;

可以替换为子查询
SELECT * FROM emp WHERE salary = (SELECT MAX(salary) FROM emp);</code></pre><ul>
<li><p>子查询的不同情况</p>
<ol>
<li><p>子查询结果是单行单列：</p>
<ul>
<li>子查询可以作为条件，使用运算符去判断。</li>
<li><code>SELECT * FROM emp WHERE salary &lt; (SELECT AVG(salary) FROM emp);</code></li>
</ul>
</li>
<li><p>子查询结果是多行单列：</p>
<ul>
<li>子查询可以作为条件，使用运算符IN去判断。</li>
<li><code>SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);</code></li>
</ul>
</li>
<li><p>子查询结果是多行多列：</p>
<ul>
<li>子查询可以作为一张虚拟表参与查询。</li>
<li><code>SELECT * FROM dept t1, (SELECT * FROM emp WHERE join_date &gt; &#39;2011-11-11&#39;) t2 WHERE t1.id = t2.dept_id;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol>
<li><p>基本介绍</p>
<ol>
<li><p>概念：</p>
<ul>
<li>如果一个包含多个步骤的业务操作，被事务处理，那么这些操作要么同时成功，要么同时失败。</li>
</ul>
</li>
<li><p>操作：</p>
<ol>
<li>开启事务：START TRANSACTION；</li>
<li>回滚：ROLLBACK；</li>
<li>提交：COMMIT；</li>
</ol>
</li>
<li><p>MySQL数据库中事务默认自动提交</p>
<ul>
<li><p>事务提交的两种方式：</p>
<ul>
<li>自动提交：<ul>
<li>MySQL就是自动提交的。</li>
<li>一条DML语句会自动提交一次事务。</li>
</ul>
</li>
<li>手动提交：<ul>
<li>Oracle默认是手动提交的。</li>
<li>需要先开启事务，再提交。</li>
</ul>
</li>
</ul>
</li>
<li><p>修改事务的默认提交方式：</p>
<ul>
<li>查看事务的默认提交方式：<code>SELECT @@AUTOCOMMIT；</code></li>
<li>修改默认提交方式：<code>SET @@AUTOCOMMIT = 0；</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>事务的四大特征</p>
<ol>
<li>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</li>
<li>持久性：当事务提交或者回滚后，数据库将会持保存数据。</li>
<li>隔离性：多个事务之间，相互独立。</li>
<li>一致性：事务操作前后数据总量不变。</li>
</ol>
</li>
<li><p>事务的隔离级别</p>
<ul>
<li><p>概念：多个事务之间，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p>
</li>
<li><p>存在问题：</p>
<ol>
<li>脏读：一个事务读取到另一个事务中没有提交的数据。</li>
<li>不可重复读（虚读）：在同一个事务中两次读取到的数据不一样。</li>
<li>幻读： 一个事务操作(DML)数据表中所有的记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</li>
</ol>
</li>
<li><p>隔离级别</p>
<ol>
<li>read uncommited：读未提交<ul>
<li>产生的问题：脏读，不可重复读，幻读。</li>
</ul>
</li>
<li>read commited：读已提交（Oracle）<ul>
<li>产生的问题：不可重复读，幻读。</li>
</ul>
</li>
<li>repeatable read：可重复读 （MySQL）<ul>
<li>产生的问题：幻读。</li>
</ul>
</li>
<li>serializable：串行化<ul>
<li>可以解决所有 的问题。</li>
</ul>
</li>
</ol>
<ul>
<li>注意：隔离级别从小到大安全性越来越高，但是效率越来越低。</li>
<li>数据库查询隔离级别：<ul>
<li>SELECT @@TX_ISOLATION；</li>
</ul>
</li>
<li>数据库设置隔离级别：<ul>
<li>SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-SQL" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/23/SQL/"
    >常用的SQL语句</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/23/SQL/" class="article-date">
  <time datetime="2020-04-22T16:00:00.000Z" itemprop="datePublished">2020-04-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/SQL%E8%AF%AD%E5%8F%A5/">SQL语句</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="常用的SQL语句"><a href="#常用的SQL语句" class="headerlink" title="常用的SQL语句"></a>常用的SQL语句</h1><hr>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>DDL是操作是数据库和表的SQL语句。</p>
<h3 id="1-操作数据库"><a href="#1-操作数据库" class="headerlink" title="1. 操作数据库"></a>1. 操作数据库</h3><ol>
<li><p><strong>创建</strong></p>
<ul>
<li><p>创建数据库</p>
<ul>
<li>CREATE DATABASE 数据库名称；</li>
</ul>
</li>
<li><p>创建数据库，判断不存在，再创建</p>
<ul>
<li>CREATE DATABASE IF NOT EXISTS 数据库名称；</li>
</ul>
</li>
<li><p>创建数据库，并指定字符集</p>
<ul>
<li>CREATE DATABASE 数据库名称 character set 字符集名；</li>
</ul>
</li>
<li><p>创建数据库，判断不存在，再创建，并指定字符集</p>
<ul>
<li>CREATE DATABASE IF NOT EXISTS 数据库名称 character set 字符集名；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>查询</strong></p>
<ul>
<li><p>查询所有数据库的名称</p>
<ul>
<li>SHOW DATABASES；</li>
</ul>
</li>
<li><p>查询某个数据库的字符集，查询某个数据库的查询语句</p>
<ul>
<li>SHOW CREATE DATABASE 数据库名称；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>修改</strong></p>
<ul>
<li>修改数据库的字符集<ul>
<li>ALTER DATABASE 数据库名称 character set 字符集名；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>删除</strong></p>
<ul>
<li><p>删除数据库</p>
<ul>
<li>DROP DATABASE 数据库名称；</li>
</ul>
</li>
<li><p>判断数据库存在，再删除</p>
<ul>
<li>DROP DATABASE IF EXISTS 数据库名称；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用数据库</strong></p>
<ul>
<li><p>查询当前正在使用的数据库名称</p>
<ul>
<li>SELECT DATABASE();</li>
</ul>
</li>
<li><p>使用数据库</p>
<ul>
<li>USE 数据库名称；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-操作表"><a href="#2-操作表" class="headerlink" title="2. 操作表"></a>2. 操作表</h3><ol>
<li><p><strong>创建</strong></p>
<ul>
<li><p>创建表</p>
<pre><code>CREATE TABLE 表名称(
    列名1，数据类型1，
    列名2，数据类型2，
    列名3，数据类型3，
    .......
    列名n，数据类型n
)；</code></pre></li>
<li><p><strong>注意最后一列后面不用加逗号</strong></p>
</li>
<li><p>SQL中常用的数据类型</p>
<ol>
<li>int：整数类型</li>
<li>double：小数类型</li>
<li>date：日期，只包含年月日，yyyy-MM-dd</li>
<li>datetime：日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss</li>
<li>timestamp：时间戳类型，包含年月日时分秒，不赋值时可以默认添加当前系统时间</li>
<li>varchar：字符串</li>
</ol>
</li>
<li><p>复制表</p>
<ul>
<li>CREATE TABLE 表名 LIKE 被复制的表名；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>查询</strong></p>
<ul>
<li>查询某个数据库中所有表的名称<ul>
<li>SHOW TABLES；</li>
</ul>
</li>
<li>查询表结构<ul>
<li>DESC 表名称；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>修改</strong></p>
<ul>
<li><p>修改表名</p>
<ul>
<li>ALTER TABLE 表名称 RENAME TO 新的表名；</li>
</ul>
</li>
<li><p>修改表的字符集</p>
<ul>
<li>ALTER TABLE 表名称 character set 字符集名；</li>
</ul>
</li>
<li><p>添加一列</p>
<ul>
<li>ALTER TABLE 表名称 ADD 列名 数据类型；</li>
</ul>
</li>
<li><p>修改列名和类型</p>
<ul>
<li>ALTER TABLE 表名称 CHANGE 列名 新列名 新数据类型；</li>
<li>ALTER TABLE 表名称 MODIFY 列名 新数据类型；</li>
</ul>
</li>
<li><p>删除列</p>
<ul>
<li>ALTER TABLE 表名称 DROP 列名；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>删除</strong></p>
<ul>
<li><p>删除表</p>
<ul>
<li>DROP TABLE 表名称；</li>
</ul>
</li>
<li><p>判断表存在，再删除</p>
<ul>
<li>DROP TABLE IF EXISTS 表名称；</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>DML是增删改数据库的表中的数据的SQL语句。</p>
<ol>
<li><p><strong>添加数据</strong></p>
<ul>
<li><p>INSERT INTO 表名(列名1，列名2，列名3，…..列名n) VALUES(值1，值2，值3，…..值n);</p>
</li>
<li><p><strong>注意：</strong></p>
</li>
</ul>
<ol>
<li><p>列名和值要一一对应。</p>
</li>
<li><p>如果表名后，不定义列名，则默认给所有列添加值。</p>
<ul>
<li>INSERT INTO 表名VALUES(值1，值2，值3，…..值n);</li>
</ul>
</li>
<li><p>除了数字类型，其他类型需要使用引号（单双引号都可以）引起来。</p>
</li>
</ol>
</li>
<li><p><strong>删除数据</strong></p>
<ul>
<li><p>DELETE FROM 表名 [WHERE 条件]；</p>
</li>
<li><p><strong>注意：如果不加条件，则删除表中所有记录。</strong></p>
</li>
<li><p><strong>如果要删除表中所有记录，不推荐使用<code>DELETE FROM 表名；</code>，可以使用<code>TRUNCATE TABLE 表名；</code>。</strong></p>
</li>
</ul>
</li>
<li><p><strong>修改数据</strong></p>
<ul>
<li><p>UPDATE 表名 SET 列名1=值1， 列名2=值2，….列名n=值n [WHERE 条件]；</p>
</li>
<li><p><strong>注意：如果不加任何条件，则会将表中所有记录修改。</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p>DQL是查询表中记录的SQL语句。</p>
<ul>
<li>SELECT * FROM 表名；</li>
</ul>
<p><strong>语法：</strong></p>
<pre><code>SELECT
    字段列表
FROM
    表名列表
WHERE
    条件列表
GROUP BY
    分组字段
HAVING
    分组之后的条件
ORDER BY
    排序
LIMIT
    分页限定</code></pre><h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1. 基础查询"></a>1. 基础查询</h3><ol>
<li><p>多个字段的查询</p>
<ul>
<li>SELECT 字段名1，字段名2… FROM 表名；</li>
</ul>
</li>
<li><p>去除重复</p>
<ul>
<li>SELECT DISTINCT 字段名1，字段名2… FROM 表名；</li>
</ul>
</li>
<li><p>计算列</p>
<ul>
<li>一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</li>
<li>IFNULL（表达式1，表达式2）：NULL参与的运算，计算结果都为NULL。<ul>
<li>表达式1：哪个字段需要判断是否为NULL。</li>
<li>表达式2：如果该字段为NULL后的替换值。</li>
</ul>
</li>
</ul>
</li>
<li><p>起别名</p>
<ul>
<li><p>SELECT 字段名1 AS 别名 FROM 表名；</p>
</li>
<li><p><strong>注意：AS也可以省略，用一个空格代替。</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2. 条件查询"></a>2. 条件查询</h3><ol>
<li><p>WHERE子句后跟条件。</p>
</li>
<li><p>运算符</p>
<ul>
<li>&lt; &gt; &gt;= &lt;= &lt;&gt; =</li>
<li>BETWEEN…AND</li>
<li>IN(集合)</li>
<li>LIKE：模糊查询<ul>
<li>占位符：<ul>
<li>_：单个任意字符。</li>
<li>%：多个任意字符。</li>
</ul>
</li>
</ul>
</li>
<li>IS NULL</li>
<li>AND 或 &amp;&amp;</li>
<li>OR 或 ||</li>
<li>NOT 或 ！</li>
</ul>
</li>
</ol>
<h3 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3. 排序查询"></a>3. 排序查询</h3><ul>
<li><p><strong>语法</strong></p>
<ul>
<li>ORDER BY 排序字段1 排序方式1，排序字段2 排序方式2….</li>
</ul>
</li>
<li><p><strong>排序方式</strong></p>
<ul>
<li><p>ASC：升序，默认的。</p>
</li>
<li><p>DESC：降序。</p>
</li>
<li><p><strong>注意：如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4. 聚合函数"></a>4. 聚合函数</h3><blockquote>
<p>将一列数据作为一个整体，进行纵向的计算。</p>
</blockquote>
<p><strong><em>注意：聚合函数的计算会排除NULL值</em></strong></p>
<p><strong><em>解决方案：1.选择不包含空的列（主键）进行计算。2.IFNULL函数。</em></strong></p>
<ol>
<li><strong>COUNT；计算个数。</strong><ul>
<li>SELECT COUNT(字段名) FROM 表名；</li>
</ul>
</li>
<li><strong>MAX；计算最大值。</strong><ul>
<li>SELECT MAX(字段名) FROM 表名；</li>
</ul>
</li>
<li><strong>MIN；计算最小值。</strong><ul>
<li>SELECT MIN(字段名) FROM 表名；</li>
</ul>
</li>
<li><strong>SUM：计算和。</strong><ul>
<li>SELECT SUM(字段名) FROM 表名；</li>
</ul>
</li>
<li><strong>AVG；计算平均值。</strong><ul>
<li>SELECT AVG(字段名) FROM 表名；</li>
</ul>
</li>
</ol>
<h3 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5. 分组查询"></a>5. 分组查询</h3><ul>
<li><p><strong>语法：</strong></p>
<ul>
<li>GROUP BY 分组字段；</li>
<li>SELECT 分组字段, 聚合函数1，…. FROM 表名 GROUP BY 分组字段;</li>
</ul>
</li>
<li><p><strong><em>注意：1.分组之后查询的字段只能是分组字段或者聚合函数。2.在分组之前可以用WHERE进行条件限定且后面不可以跟聚合函数判断，如果要在分组之后进行条件限定需要用HAVING且后面可以跟聚合函数判断。</em></strong></p>
<p>  <code>SELECT 分组字段, 聚合函数1，.... FROM 表名 WHERE 条件 GROUP BY 分组字段 HAVING 条件;</code></p>
</li>
</ul>
<h3 id="6-分页查询"><a href="#6-分页查询" class="headerlink" title="6. 分页查询"></a>6. 分页查询</h3><ul>
<li><strong>语法：</strong><ul>
<li>LIMIT 开始的索引，每页查询的条数；</li>
<li>SELECT * FROM 表名 LIMIT 开始的索引, 每页查询的条数;</li>
</ul>
</li>
</ul>
<p><strong><em>LIMIT是一个“方言”，只能在MySQL中用。</em></strong></p>
<hr>
<h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="1-管理用户"><a href="#1-管理用户" class="headerlink" title="1.管理用户"></a>1.管理用户</h3><ol>
<li><p>添加用户：</p>
<ul>
<li>CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’；</li>
</ul>
</li>
<li><p>删除用户：</p>
<ul>
<li>DROP USER ‘用户名‘@’主机名’；</li>
</ul>
</li>
<li><p>修改用户密码：</p>
<ul>
<li><p>UPDATE USER SET PASSWORD = PASSWORD(‘新密码’) WHERE USER = ‘用户名’；</p>
</li>
<li><p>SET PASSWORD FOR ‘用户名‘@’主机名’ = PASSWORD(‘新密码’)；</p>
</li>
<li><p><strong>MySQL中忘记了root用户的密码怎么办？</strong></p>
<ol>
<li>cmd –&gt; net stop mysql80 停止mysql服务</li>
<li>使用无验证方式启动mysql服务：mysqld –skip-grant-tables</li>
<li>打开新的cmd窗口，直接输入mysql命令，敲回车，就可以登陆成功</li>
<li>USE mysql；</li>
<li>UPDATE USER SET PASSWORD = PASSWORD(‘新密码’) WHERE USER = ‘root’；</li>
<li>关闭两个窗口</li>
<li>打开任务管理器，手动关闭mysqld.exe的进程</li>
<li>启动mysql服务</li>
<li>使用新密码登录</li>
</ol>
</li>
</ul>
</li>
<li><p>查询用户：</p>
<ol>
<li>切换到mysql数据库。<code>USE mysql;</code></li>
<li>查询user表。<code>SELECT * FROM user;</code></li>
</ol>
<ul>
<li>通配符：%表示可以在任意主机使用用户登录数据库。</li>
</ul>
</li>
</ol>
<h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2.权限管理"></a>2.权限管理</h3><ol>
<li><p>查询权限：</p>
<ul>
<li>SHOW GRANTS FOR ‘用户名‘@’主机名’;</li>
</ul>
</li>
<li><p>授予权限</p>
<ul>
<li>GRANT 权限列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;</li>
<li>GRANT ALL ON <em>.</em> TO ‘用户名‘@’主机名’; 给一个用户授予对任意数据库中任意表进行任意操作的权限。</li>
</ul>
</li>
<li><p>撤销权限</p>
<ul>
<li>REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’;</li>
</ul>
</li>
</ol>
<hr>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p>
<p>分类：</p>
<ol>
<li>主键约束：primary key</li>
<li>非空约束：not null</li>
<li>唯一约束：unique</li>
<li>外键约束：foreign key</li>
</ol>
<h3 id="1-非空约束"><a href="#1-非空约束" class="headerlink" title="1.非空约束"></a>1.非空约束</h3><p>某一列的值不能为NULL。</p>
<ul>
<li><p>创建表时添加非空约束</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2 NOT NULL，
    .....
);</code></pre></li>
<li><p>创建表完后添加非空约束</p>
<p>  <code>ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL；</code></p>
</li>
<li><p>删除非空约束</p>
<p>  <code>ALTER TABLE 表名 字段名 数据类型；</code></p>
</li>
</ul>
<h3 id="2-唯一约束"><a href="#2-唯一约束" class="headerlink" title="2.唯一约束"></a>2.唯一约束</h3><p>某一列的值不能重复。</p>
<ul>
<li><p>创建表时，添加唯一约束</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2 UNIQUE，
    .....
);</code></pre></li>
<li><p>删除唯一约束</p>
<p>  <code>ALTER TABLE 表名 DROP INDEX 字段名；</code></p>
</li>
<li><p>在表创建完后，添加唯一约束</p>
<p>  <code>ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE；</code></p>
</li>
</ul>
<h3 id="3-主键约束"><a href="#3-主键约束" class="headerlink" title="3.主键约束"></a>3.主键约束</h3><p>某一列的值非空且唯一，一张表只能有一个字段为主键，就是表中记里的唯一标识。</p>
<ul>
<li><p>创建表时，添加主键约束</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2 PRIMARY KEY，
    .....
);</code></pre></li>
<li><p>删除主键</p>
<p>  <code>ALTER TABLE 表名 DROP PRIMARY KEY；</code></p>
</li>
<li><p>创建完表后，添加主键</p>
<p>  <code>ALTER TABLE 表名 MODIFY 字段名 数据类型 PRMARY KEY；</code></p>
</li>
<li><p>自动增长</p>
<ul>
<li><p>如果某一列是数值类型，使用AUTO_INCREMENT可以完成值自动增长，一般可以配合数值类型的主键使用。</p>
</li>
<li><p><strong>注意：自动增长的值为最后一条记录自动增长字段的值加一</strong></p>
</li>
<li><p>创建表时，添加主键，并且完成自动增长</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2 PRIMARY KEY AUTO_INCREMENT，
    .....
);</code></pre></li>
<li><p>删除自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 字段名 数据类型；</code></p>
</li>
<li><p>添加自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 字段名 数据类型 AUTO_INCREMENT；</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-外键约束"><a href="#4-外键约束" class="headerlink" title="4.外键约束"></a>4.外键约束</h3><p>让表与表产生关系，从而保证数据的正确性，外键可以为NULL，但是不能是主表中不存在的值。</p>
<ul>
<li><p>创建表时，添加外键</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2，
    .....
    CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称)
);</code></pre></li>
<li><p>删除外键</p>
<p>  <code>ALTER TABLE 表名称 DROP FOREIGN KEY 外键名称；</code></p>
</li>
<li><p>创建表之后，添加外键</p>
<p>  <code>ALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称)；</code></p>
</li>
<li><p>级联操作</p>
<p>  可以在外键关联的主表中的列进行操作时，外键中的值自动更新。</p>
<ul>
<li><p>级联更新</p>
<ul>
<li><p>在添加外键语句后加上ON UPDATE CASCADE</p>
<p><code>ALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE；</code></p>
</li>
</ul>
</li>
<li><p>级联删除</p>
<ul>
<li><p>在添加外键语句后加上ON DELETE CASCADE</p>
<p><code>ALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称) ON DELETE CASCADE；</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><em>级联更新与级联删除可以同时存在。</em></strong></p>
<hr>
<h2 id="命令行操作数据库备份和还原"><a href="#命令行操作数据库备份和还原" class="headerlink" title="命令行操作数据库备份和还原"></a>命令行操作数据库备份和还原</h2><ul>
<li><p>备份：MYSQLDUMP -u用户名 -p密码 数据库名称 &gt; 保存的路径；</p>
</li>
<li><p>还原：</p>
<ol>
<li>登录数据库</li>
<li>创建数据库</li>
<li>使用数据库</li>
<li>使用文件。SOURCE 文件路径</li>
</ol>
</li>
</ul>
<hr>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        Zhang SiFan
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <a href="http://www.beian.miit.gov.cn/" target="_black">浙ICP备20014029号</a>
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="小张日记"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>
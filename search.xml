<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bootstrap</title>
    <url>/2020/05/05/Bootstrap/</url>
    <content><![CDATA[<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><ul>
<li><p>概念：一个前端开发的框架。Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。</p>
<ul>
<li>框架：一个半成品软件。开发人员可以在框架基础上再进行开发，简化编码。</li>
<li>好处：<ol>
<li>定义了很多的css样式和js插件。我们开发人员可以直接使用这些样式和插件得到丰富的页面效果。</li>
<li>响应式布局。<ul>
<li>同一套页面可以兼容不同分辨率的设备。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li>下载Bootstrap</li>
<li>在项目中将下载解压完的文件中的三个文件夹复制</li>
<li>创建html页面，引入必要的资源文件</li>
</ol>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><ul>
<li><p><strong>实现</strong>：依赖于栅格系统。</p>
<ul>
<li>栅格系统：将一行平均分割成12个格子，可以指定元素占几个格子。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>定义容器<ul>
<li>容器分类：<ol>
<li>container：固定宽度。每一种设备的宽度都是一个不同的固定值</li>
<li>container-fluid：每一种设备都是100%宽度</li>
</ol>
</li>
</ul>
</li>
<li>定义行 样式：row</li>
<li>定义元素。指定该元素在不同的设备上占用的格子数目 样式：col-设备代号-格子数目<ul>
<li>设备代号：<ol>
<li>xs：超小屏幕 手机(&lt;768px)</li>
<li>sm：小屏幕 平板(&gt;=768px)</li>
<li>md：中等屏幕 桌面显示器(&gt;=992px)</li>
<li>lg：大屏幕 大桌面显示器(&gt;=1200px)</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>注意：</strong><ol>
<li>一行中如果格子数目超过12，则超出部分自动换行</li>
<li>栅格类属性可以向上兼容</li>
<li>如果真实设备的宽度小于了设置的栅格类属性的设备代码的最小值，会一个元素占满一整行</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><p>全局CSS样式：</p>
<ul>
<li>按钮：例如 <code>btn btn-default</code></li>
<li>图片：<ul>
<li>响应式图片 <code>class=&quot;img-responsive&quot;</code></li>
<li>图片形状例如 <code>class=&quot;img-rounded&quot;</code></li>
</ul>
</li>
<li>表格：查看文档</li>
<li>表单：查看文档</li>
</ul>
<p>组件：</p>
<ul>
<li>导航条：navbar</li>
<li>分页条：pagination</li>
</ul>
<p>插件：</p>
<ul>
<li>轮播图：Carousel</li>
</ul>
<hr>
<p>Bootstrap更多用法请自询查找文档，上面很详细。</p>
]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2020/05/01/JavaScript/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="ECMAScript：客户端脚本语言的标准"><a href="#ECMAScript：客户端脚本语言的标准" class="headerlink" title="ECMAScript：客户端脚本语言的标准"></a>ECMAScript：客户端脚本语言的标准</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><ol>
<li>与html结合方式<ol>
<li>内部js：定义&lt; script&gt;js代码&lt; script/&gt;</li>
<li>外部js：定义&lt; script src属性引入外部js文件&gt;js代码&lt; script/&gt;</li>
</ol>
<ul>
<li><strong>注意：&lt; script&gt;可以定义在html页面的任何地方，但是定义的位置会影响执行的顺序。&lt; script&gt;标签可以定义多个。</strong></li>
</ul>
</li>
<li>注释<ul>
<li>和java中注释规则一样。</li>
</ul>
</li>
<li>数据类型<ol>
<li>原始数据类型：<ol>
<li>number：数字。整数/小数/NaN（not a number 一个不是数字的数字类型）</li>
<li>string：字符串</li>
<li>boolean：true/false</li>
<li>null：空</li>
<li>undefined：未定义。如果一个对象没有给初始化值，则会被默认赋值为undefined</li>
</ol>
</li>
<li>引用数据类型：对象</li>
</ol>
</li>
<li>变量<ul>
<li>Java是强类型语言，而JavaScript是弱类型语言。<ul>
<li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型，只能存储固定的数据类型。</li>
<li>弱类型：在开辟变量存储空间时，不定义空间将来存储的数据的数据类型，可以存放任意的数据类型。</li>
</ul>
</li>
<li>语法：var 变量名=变量值；</li>
</ul>
</li>
<li>运算符<ul>
<li>一元运算符：只有一个运算数的运算符<ul>
<li>++，–，+（正号），-（负号），等</li>
<li><strong>注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。</strong><ul>
<li><strong>其他类型转number：</strong><ul>
<li><strong>string转number，按照字面值转换，如果字面值不是数字，则转为NaN（不是数字的数字）</strong></li>
<li><strong>boolean转number，true转为1，false转为0</strong></li>
<li><strong>其他两种类型转为NaN</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>算数运算符：数学运算<ul>
<li>+，-，*，/，%等</li>
</ul>
</li>
<li>赋值运算符<ul>
<li>=，+=，-=等</li>
</ul>
</li>
<li>比较运算符<ul>
<li>&lt;，&gt;，&gt;=，&lt;=，==，===（全等于）</li>
<li>比较方式：<ol>
<li>类型相同：直接比较。</li>
<li>类型不同：先进行类型转换再进行比较。</li>
</ol>
</li>
<li>===（全等于）：在比较之前，先判断类型，如果类型不一样，则直接返回false。</li>
</ul>
</li>
<li>逻辑运算符<ul>
<li>&amp;&amp;，||，！</li>
<li>其他类型转为boolean类型：<ul>
<li>number：0或NaN为false，其他都是true</li>
<li>string：除了空字符串（“”），其他都是true</li>
<li>null与undefined：都是false</li>
<li>对象：所有对象都为true</li>
</ul>
</li>
</ul>
</li>
<li>三元运算符<ul>
<li>?:表达式</li>
</ul>
</li>
</ul>
</li>
<li>流程控制语句<ul>
<li>if…else…</li>
<li>switch<ul>
<li>在JS中，switch可以接收任意原始数据类型</li>
</ul>
</li>
<li>while</li>
<li>do…while</li>
<li>for</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-基本对象"><a href="#2-基本对象" class="headerlink" title="2.基本对象"></a>2.基本对象</h3><ul>
<li>Function：函数对象<ol>
<li>创建<ol>
<li><code>var fun = new Function(形参列表，方法体)</code></li>
<li><code>function 方法名称(形参列表){方法体}</code></li>
<li><code>var 方法名 = function(形参列表){方法体}</code></li>
</ol>
</li>
<li>方法</li>
<li>属性<ul>
<li>length：代表形参的个数</li>
</ul>
</li>
<li>特点<ol>
<li>方法定义时，形参的类型可以不用写，返回值类型也bu’xie</li>
<li>方法是一个对象，如果定义一个名称相同的方法，会覆盖之前的方法</li>
<li>在JS中，方法的调用只与方法的名称有关，和参数列表无关</li>
<li>在方法声明中有一个隐藏的内置对象（数组），arguments，封装所有的实际参数</li>
</ol>
</li>
<li>调用：<ul>
<li>方法名称(参数列表)；</li>
</ul>
</li>
</ol>
</li>
<li>Array：数组对象<ol>
<li>创建<ol>
<li><code>var arr = new Array(元素列表)；</code></li>
<li><code>var arr = new Array(数组长度)；</code></li>
<li><code>var arr = [元素列表]；</code></li>
</ol>
</li>
<li>方法<ul>
<li>join(参数)：将数组的元素按照指定的分隔符拼接为字符串</li>
<li>push()：向数组中的末尾添加一个元素，并返回新的长度</li>
</ul>
</li>
<li>属性<ul>
<li>length：数组的长度</li>
</ul>
</li>
<li>特点<ol>
<li>JS中，数组元素的类型是可变的</li>
<li>JS中，数组的长度是可变的</li>
</ol>
</li>
</ol>
</li>
<li>Boolean</li>
<li>Date<ol>
<li>创建<ol>
<li><code>var date = new Date()；</code></li>
</ol>
</li>
<li>方法<ul>
<li>toLocalString()：返回本地时间字符串格式</li>
<li>getTime()：获取毫秒值，返回当前日期对象描述的时间到970年1月1日0点的差</li>
</ul>
</li>
<li>属性</li>
<li>特点</li>
</ol>
</li>
<li>Math<ol>
<li>创建<ul>
<li>不用创建，直接使用</li>
</ul>
</li>
<li>方法<ul>
<li>random()：返回0到1之间的随机数，包含0不包含1</li>
<li>cell(x)：向上取整</li>
<li>floor(x)：向下取整</li>
<li>round(x)：四舍五入</li>
</ul>
</li>
<li>属性<ul>
<li>PI：圆周率</li>
</ul>
</li>
<li>特点</li>
</ol>
</li>
<li>Number</li>
<li>String</li>
<li>RegExp：正则表达式对象<ul>
<li>正则表达式：定义字符串的组成规则<ol>
<li>单个字符：[]</li>
</ol>
<ul>
<li>如：[a] [ab] [a-zA-Z0-9_]</li>
<li>特殊符号代表特殊含义的单个字符：<ul>
<li>\d：单个数字字符 [0-9]</li>
<li>\w：单个单词字符 [a-zA-Z0-9_]</li>
</ul>
</li>
</ul>
<ol start="2">
<li>量词符号：<ul>
<li>?：表示出现0次或1次</li>
<li>*：表示出现0次或多次</li>
<li>+：表示出现1次或多次</li>
<li>{m,n}：表示出现次数在m与n之中，包括m和n<ul>
<li>{m,}：至少出现m次</li>
<li>{,n}：至多出现n次</li>
</ul>
</li>
</ul>
</li>
<li>开始结束符号：<ul>
<li>^：开始</li>
<li>$：结束</li>
</ul>
</li>
</ol>
</li>
<li>正则对象<ol>
<li>创建<ul>
<li><code>var reg = new RegExp(&quot;正则表达式&quot;)；</code><ul>
<li><strong>注意：正则表达式中的\应该写两个，因为在双引号中会被转义</strong></li>
</ul>
</li>
<li><code>var reg = /正则表达式/；</code></li>
</ul>
</li>
<li>方法<ul>
<li>test(参数)：验证指定的字符串是否符合正则表达式</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>Global<ol>
<li>特点：全局对象，这个Global对象中封装的方法可以不需要对象就直接调用。 方法名();</li>
<li>方法：<ul>
<li>encodeURI()：url编码</li>
<li>decodeURI()：url解码</li>
<li>encodeURIComponent()：url编码，会进行编码的字符更多</li>
<li>decodeURIComponent()：url解码</li>
<li>parseInt()：将字符串转为数字<ul>
<li>逐一判断每个字符是不是是否是数字，直到不是数字为止，将前变数字部分转换为number</li>
</ul>
</li>
<li>isNaN()：判断一个字符是不是NaN</li>
<li>eval()：将JavaScript字符串，转成脚本来执行</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-BOM对象"><a href="#3-BOM对象" class="headerlink" title="3.BOM对象"></a>3.BOM对象</h3><ul>
<li><p>概念：Browser object Model 浏览器对象模型</p>
<ul>
<li>将浏览器的各个组成部分封装成对象。</li>
</ul>
</li>
<li><p>组成：</p>
<ol>
<li>Window：窗口对象<ul>
<li>创建</li>
<li>方法：<ol>
<li>与弹出框有关的方法<ul>
<li>alert()：显示带有一段消息和一个确认按钮的警告框。</li>
<li>confirm()：显示带有一段信息以及确认按钮和取消按钮的对话框。<ul>
<li>用户点击确认按钮，则返回true</li>
<li>用户点击取消按钮，则返回false</li>
</ul>
</li>
<li>prompt()：显示可提示用户输入的对话框。<ul>
<li>返回值。获取用户输入的值。</li>
</ul>
</li>
</ul>
</li>
<li>与打开关闭有关的方法：<ul>
<li>open()：打开一个新的浏览器窗口</li>
<li>close()：关闭浏览器窗口</li>
</ul>
</li>
<li>与定时器有关的方法<ul>
<li>setTimeout()：在指定的毫秒数后调用函数或计算表达式。<ul>
<li>参数：<ul>
<li>参数1：js代码或者方法对象</li>
<li>参数2：毫秒值</li>
</ul>
</li>
<li>返回值：唯一标识</li>
</ul>
</li>
<li>clearTimeout()：取消由setTimeout()方法设置的timeout。</li>
<li>setInterval()：按照指定的周期（以毫秒计）来调用函数或表达式。<ul>
<li>参数：<ul>
<li>参数1：js代码或者方法对象</li>
<li>参数2：毫秒值</li>
</ul>
</li>
<li>返回值：唯一标识</li>
</ul>
</li>
<li>clearInterval()：取消seItnterval()设置的timeout。</li>
</ul>
</li>
</ol>
</li>
<li>属性<ul>
<li>获取其他BOM对象：<ul>
<li>history</li>
<li>location</li>
<li>Navigator</li>
<li>Screen</li>
</ul>
</li>
<li>获取DOM对象<ul>
<li>document</li>
</ul>
</li>
</ul>
</li>
<li>特点：<ol>
<li>不需要创建，可以直接使用window使用。window.方法名()；</li>
<li>window引用可以省略。方法名()；</li>
</ol>
</li>
</ul>
</li>
<li>Navigator：浏览器对象</li>
<li>Screen：显示器屏幕对象</li>
<li>History：历史记录对象<ul>
<li>创建(获取)<ol>
<li>window.history</li>
<li>history</li>
</ol>
</li>
<li>方法<ul>
<li>back() 加载history列表中的前一个URL</li>
<li>forward() 加载history列表中的下一个URL</li>
<li>go() 加载history列表中的某个具体页面<ul>
<li>参数：<ul>
<li>正数：前进几个历史记录</li>
<li>负数：后退几个历史记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>属性<ul>
<li>length：返回当前窗口历史记录列表中的URL数量</li>
</ul>
</li>
</ul>
</li>
<li>Location：地址栏对象<ol>
<li>创建(获取)<ul>
<li>window.location</li>
<li>location</li>
</ul>
</li>
<li>方法<ul>
<li>reload() 重新加载当前文档。刷新</li>
</ul>
</li>
<li>属性<ul>
<li>href 设置或返回完整的URL</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-DOM对象"><a href="#4-DOM对象" class="headerlink" title="4.DOM对象"></a>4.DOM对象</h3><ul>
<li><p>概念：Document Object Model 文档对象模型</p>
<ul>
<li>将标记语言文档的各个组成部分封装为对象。可以使用这些个对象，对标记语言文档进行CRUD的动态操作。</li>
</ul>
</li>
<li><p>功能：控制html文档的内容</p>
</li>
<li><p>W3C DOM标准被分为3个不同的部分</p>
<ul>
<li>核心DOM：针对任何结构化文档的标准模型<ul>
<li>Document对象：文档对象</li>
<li>Element：元素对象</li>
<li>Attribute：属性对象</li>
<li>Text：文本对象</li>
<li>Comment：注释对象</li>
<li>Node：节点对象，其他五个的父对象</li>
</ul>
</li>
<li>XML DOM：针对XML文档的标准模型</li>
<li>HTML DOM：针对HTML文档的标准模型</li>
</ul>
</li>
<li><p>核心DOM模型：</p>
<ul>
<li>Document对象：文档对象<ol>
<li>创建(获取)：在htnl模型中可以使用window对象来获取<ol>
<li>window.document</li>
<li>document</li>
</ol>
</li>
<li>方法：<ul>
<li>获取Element对象：<ul>
<li>getElementById() 根据id属性值获取元素对象。</li>
<li>getElementsByTagName() 根据元素名称获取元素对象们，返回值是一个数组</li>
<li>getElementsByClassName() 根据class的属性值来获取元素对象们</li>
<li>getElementsByName() 根据Name属性值获取元素对象们</li>
</ul>
</li>
<li>创建其他DOM对象：<ul>
<li>createAttribute(Name)</li>
<li>createComment()</li>
<li>createElement()</li>
<li>createTextNode()</li>
</ul>
</li>
</ul>
</li>
<li>属性：<ul>
<li>parentNode：获取父节点</li>
</ul>
</li>
</ol>
</li>
<li>Element：元素对象<ol>
<li>获取：通过Document对象来获取和创建</li>
<li>方法：<ul>
<li>removeAttribute()：删除属性</li>
<li>setAttribute()：设置属性</li>
</ul>
</li>
</ol>
</li>
<li>Node：节点对象，其他五个的父对象<ul>
<li>特点：所有DOM对象都可以被认为是一个节点</li>
<li>方法：<ul>
<li>COUR DOM树：<ul>
<li>appendChild()：向节点的子节点列表的结尾添加新的子节点。</li>
<li>removeChild()：删除(并返回)当前节点的指定子节点。</li>
<li>replaceChild()：用新的节点替换一个子节点</li>
</ul>
</li>
</ul>
</li>
<li>属性：</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>HTML DOM</li>
</ul>
<ol>
<li><p>标签体的设置和获取：innerHTML</p>
</li>
<li><p>使用html元素对象的属性：查询API文档</p>
</li>
<li><p>控制元素样式：</p>
<ol>
<li>使用元素的style属性来设置</li>
<li>提前定义好类选择器的样式，通过元素的className属性来设置类属性值。</li>
</ol>
</li>
</ol>
<ul>
<li><p>操作Element对象</p>
<ol>
<li>修改属性值<ol>
<li>明确获取的对象是哪一个？</li>
<li>查看API文档，看其中有哪些属性值可以设置</li>
</ol>
</li>
<li>修改标签体内容<ul>
<li>属性：innerHTML</li>
</ul>
</li>
</ol>
</li>
<li><p>事件简单学习</p>
<ul>
<li>功能：某些组件被执行了某些操作后触发某些代码的执行</li>
<li>如何绑定事件：<ol>
<li>直接在html标签上，指定事件的属性，属性值就是js代码</li>
<li>通过js获取元素对象，指定事件属性</li>
</ol>
</li>
</ul>
</li>
<li><p>事件</p>
<ul>
<li>常见的事件：<ol>
<li>点击事件：<ol>
<li>onclick：当用户点击某个对象时调用的事件句柄。</li>
<li>ondblclick：双击事件</li>
</ol>
</li>
<li>焦点事件：<ol>
<li>onblur：失去焦点<ul>
<li>可以用于表单验证</li>
</ul>
</li>
<li>onfocus：元素获得焦点</li>
</ol>
</li>
<li>加载事件：<ol>
<li>onload：一张页面或一张图片完成加载</li>
</ol>
</li>
<li>鼠标事件：<ol>
<li>onmousedown：鼠标按钮被按下<ul>
<li>定义方法时，定义一个形参，接受event对象</li>
<li>event对象的button属性可以获取哪个鼠标按钮键被点击了</li>
</ul>
</li>
<li>onmouseup：鼠标按键被松开</li>
<li>onmousemove：鼠标被移动</li>
<li>onmouseover：鼠标移到某元素之上</li>
<li>onmouseout：鼠标从某元素移开</li>
</ol>
</li>
<li>键盘事件：<ol>
<li>onkeydown：键盘某个按键被按下</li>
<li>onkeyup：键盘某个按键被松开</li>
<li>onkeypress：键盘按下并松开</li>
</ol>
</li>
<li>选中和改变：<ol>
<li>onchange：域的内容被改变</li>
<li>onselect：文本被选中</li>
</ol>
</li>
<li>表单事件：<ol>
<li>onsubmit：确认按钮被点击<ul>
<li>可以阻止表单的提交，方法返回true则提交，返回false则不提交</li>
</ul>
</li>
<li>onreset：重置按钮被点击</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2020/05/01/CSS/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>页面美化和布局控制</p>
<ul>
<li><p>概念：Cascading Style Sheets 层叠样式表</p>
<ul>
<li>层叠：多个样式可以作用在同一个html的元素上，同时生效</li>
</ul>
</li>
<li><p>好处</p>
<ol>
<li>功能强大</li>
<li>将内容的展示和样式控制分离<ul>
<li>降低耦合度</li>
<li>让分工协作更容易</li>
<li>提高开发效率</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="CSS的使用：CSS与html结合方式"><a href="#CSS的使用：CSS与html结合方式" class="headerlink" title="CSS的使用：CSS与html结合方式"></a>CSS的使用：CSS与html结合方式</h2><ol>
<li><p>内联样式：在标签内使用style属性指定css代码</p>
<ul>
<li>如：&lt; div style=”color:red;”&gt;hello&lt; /div&gt;</li>
</ul>
</li>
<li><p>内部样式：在head标签内，定义style标签，style标签的内容就是css代码</p>
<ul>
<li><p>如</p>
<pre><code>&lt;head&gt;
    &lt;style&gt;
        div{
            color:blue;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;div&gt;hello&lt;/div&gt;</code></pre></li>
</ul>
</li>
<li><p>外部样式:定义css资源文件，在head标签内，定义link标签，引入外部资源文件。</p>
</li>
</ol>
<ul>
<li><p>如</p>
<pre><code>&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;
&lt;/head&gt;

&lt;div&gt;hello&lt;/div&gt;</code></pre></li>
</ul>
<h2 id="CSS基本语法"><a href="#CSS基本语法" class="headerlink" title="CSS基本语法"></a>CSS基本语法</h2><ul>
<li><p>格式：</p>
<pre><code>选择器{
    属性名1：属性值1；
    属性名2：属性值2；
    .....
}</code></pre></li>
<li><p>选择器：筛选具有相似特征的元素</p>
</li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul>
<li><p>分类：</p>
<ol>
<li><p>基础选择器</p>
<ol>
<li>id选择器：选择具体的id属性值的元素。<ul>
<li>语法：#id属性值{}</li>
<li><strong>优先级最高</strong></li>
</ul>
</li>
<li>元素选择器：选择具有相同标签名称的元素。<ul>
<li>语法：标签名称{}</li>
<li><strong>优先级低于id选择器和类选择器</strong></li>
</ul>
</li>
<li>类选择器：选择具有相同的class属性值的元素。<ul>
<li>语法：.class属性值{}</li>
<li><strong>优先级低于id选择器</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>扩展选择器</p>
<ol>
<li>*：表示选择所有元素<ul>
<li>语法：*{}</li>
</ul>
</li>
<li>并集选择器：筛选选择器1下和选择器2共有的元素<ul>
<li>语法：选择器1，选择器2{}</li>
</ul>
</li>
<li>子选择器：筛选选择器1下的选择器2的元素<ul>
<li>语法：选择器1 选择器2{}</li>
</ul>
</li>
<li>父选择器：：筛选选择器2的父元素选择器1<ul>
<li>语法：选择器1&gt;选择器2{}</li>
</ul>
</li>
<li>属性选择器：选择元素名称，属性名=属性值的元素<ul>
<li>语法：元素名称[ 属性名=”属性值” ]{}</li>
</ul>
</li>
<li>伪类选择器：选择一些元素所具有的状态<ul>
<li>语法：元素:状态{}</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li><p>字体、文本</p>
<ul>
<li>font-size：字体大小</li>
<li>color：文本颜色</li>
<li>text-align：文本对齐方式</li>
<li>line-height：行高</li>
</ul>
</li>
<li><p>背景</p>
<ul>
<li>background：复合属性。</li>
</ul>
</li>
<li><p>边框</p>
<ul>
<li>border：设置边框，复合属性。</li>
</ul>
</li>
<li><p>尺寸</p>
<ul>
<li>width：宽度</li>
<li>height：高度</li>
</ul>
</li>
<li><p>盒子模型：控制布局</p>
<ul>
<li>margin：外边距</li>
<li>padding：内边距<ul>
<li>默认情况下内边距会影响整个盒子的大小，可以使用box-sizing：boder-box，让width和height就是盒子最终大小。</li>
</ul>
</li>
<li>float：浮动</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池</title>
    <url>/2020/04/28/ConnPool/</url>
    <content><![CDATA[<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><ul>
<li><p><strong>概念：</strong> 其实就是一个容器（集合），存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
</li>
<li><p><strong>好处：</strong> </p>
<ol>
<li>节约资源</li>
<li>用户访问高效</li>
</ol>
</li>
<li><p><strong>实现：</strong></p>
<ol>
<li><p>标准接口：DataSource</p>
<ol>
<li>方法：<ul>
<li>获取连接：getConnection()</li>
<li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了，而是归还连接。</li>
</ul>
</li>
</ol>
</li>
<li><p>一般我们不去实现它，有数据库厂商来实现</p>
<ol>
<li>C3P0：数据库连接池技术。</li>
<li>Druid：数据库连接池技术，由阿里巴巴提供。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="C3P0：数据库连接池技术"><a href="#C3P0：数据库连接池技术" class="headerlink" title="C3P0：数据库连接池技术"></a>C3P0：数据库连接池技术</h2><ul>
<li>步骤：<ol>
<li>导入jar包（两个） c3p0-0.9.5.5-sources.jar和mchange-commons-java-0.2.19-sources.jar</li>
<li>定义配置文件：<ul>
<li>名称：c3p0.properties或者c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可</li>
</ul>
</li>
<li>创建核心对象：数据库连接池对象 ComboPooledDataSource</li>
<li>获取连接：getConnection</li>
</ol>
</li>
</ul>
<h2 id="Druid：数据库连接池技术，由阿里巴巴提供"><a href="#Druid：数据库连接池技术，由阿里巴巴提供" class="headerlink" title="Druid：数据库连接池技术，由阿里巴巴提供"></a>Druid：数据库连接池技术，由阿里巴巴提供</h2><ul>
<li><p>步骤：</p>
<ol>
<li>导入jar包 druid-1.1.22.jar</li>
<li>定义配置文件：<ul>
<li>是properties形式的</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>获取数据库连接池对象：加载配置文件，然后通过工厂来获取 DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
</li>
<li><p>定义工具类</p>
<ol>
<li>定义一个类 JDBCUtils</li>
<li>提供静态代码块加载配置文件，初始化连接池对象</li>
<li>提供方法：<ol>
<li>获取连接方法：通过数据库连接池获取连接</li>
<li>释放资源</li>
<li>获取连接池对象的方法</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>代码实现示例</strong></p>
<pre><code>    public class JDBCUtils {

    private static DataSource ds;

    //数据库连接池的初始化
    static {
        try {
            Properties prop = new Properties();
            prop.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
            ds = DruidDataSourceFactory.createDataSource(prop);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //获取连接的方法
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }

    //释放资源的方法
    public static void close(Connection conn, Statement st, ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
        if (st != null) {
            try {
                st.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }

    //释放资源的方法
    public static void close(Connection conn, Statement st) {
        close(conn, st, null);
    }

    //获取连接池对象的方法
    public static DataSource getDataSource() {
        return ds;
    }

}</code></pre></li>
</ul>
<h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><ul>
<li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发。</p>
</li>
<li><p>步骤：</p>
<ol>
<li>导入jar包。</li>
<li>创建JDBCTemplate对象。依赖于数据源DataSource。</li>
<li>调用DBCTemplate来完成增删改查的操作。<ul>
<li>update()：执行DML语句。</li>
<li>queryForMap()：查询结果将结果集封装为Map集合，将一条记录封装为Map集合。<ul>
<li>注意：这个方法查询的结果集长度只能是1。</li>
</ul>
</li>
<li>queryForList()：查询结果将结果集封装为List集合。<ul>
<li>注意：将每一条记录封装为Map集合，再将map集合装载到List集合中。</li>
</ul>
</li>
<li>query()：查询结果将结果封装为JavaBean对象。<ul>
<li>参数：RowMapper<ul>
<li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li>
<li>new BeanPropertyRowMapper&lt;类型&gt;（类型.class）</li>
</ul>
</li>
</ul>
</li>
<li>queryForObject()：查询结果将结果封装为对象。<ul>
<li>一般用于聚合函数的查询。</li>
<li>queryForObject(sql语句, 返回值类型.class);</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2020/04/28/HTML/</url>
    <content><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul>
<li>概念：是最基础的网页开发语言<ul>
<li>Hyper Text Markup Language 超文本标记语言<ul>
<li>超文本：超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。</li>
<li>标记语言：由标签构成的语言。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="几类标签的学习"><a href="#几类标签的学习" class="headerlink" title="几类标签的学习"></a>几类标签的学习</h2><h3 id="1-文件标签：构成html最基本的标签"><a href="#1-文件标签：构成html最基本的标签" class="headerlink" title="1.文件标签：构成html最基本的标签"></a>1.文件标签：构成html最基本的标签</h3><ul>
<li>htlm：html文档的根标签。</li>
<li>head：头标签。用于指定html文档的一些属性。引入外部的资源。</li>
<li>title：标题标签。</li>
<li>body：体标签。</li>
<li>&lt; !DOCTYPE html &gt; ：html5中定义该文档是html文档。</li>
</ul>
<h3 id="2-文本标签：和文本有关的标签"><a href="#2-文本标签：和文本有关的标签" class="headerlink" title="2.文本标签：和文本有关的标签"></a>2.文本标签：和文本有关的标签</h3><ul>
<li><p>注释：&lt; !–注释内容–&gt;</p>
</li>
<li><p>&lt; h1&gt; to &lt; h6&gt;：标题标签</p>
</li>
<li><p>&lt; p&gt;：段落标签</p>
</li>
<li><p>&lt; br&gt;：换行</p>
</li>
<li><p>&lt; hr&gt;：显示一条水平线</p>
</li>
<li><p>&lt; b&gt;：粗体</p>
</li>
<li><p>&lt; i&gt;：斜体</p>
</li>
<li><p>&lt; center&gt;：文本居中</p>
</li>
<li><p>&lt; font&gt;：字体标签(HTML5不再支持)</p>
<ul>
<li>color：颜色</li>
<li>size：大小</li>
<li>face：字体</li>
</ul>
</li>
<li><p>属性定义：(HTML5中也推荐不再支持)</p>
<ul>
<li>color：<ol>
<li>英文单词定义</li>
<li>rgb(值1，值2，值3)</li>
<li>#值1值2值3，值为十六进制</li>
</ol>
</li>
<li>width：<ol>
<li>数值：width=’20’，数值单位默认是px(像素)</li>
<li>%数值：表示相对于父元素的占比</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-图片标签"><a href="#3-图片标签" class="headerlink" title="3.图片标签"></a>3.图片标签</h3><ul>
<li>&lt; img&gt;：展示一张图片<ul>
<li>以./开头的路径表示以当前目录开始</li>
<li>以../开头的路径表示退回上一层路径</li>
</ul>
</li>
</ul>
<h3 id="4-列表标签"><a href="#4-列表标签" class="headerlink" title="4.列表标签"></a>4.列表标签</h3><ul>
<li>有序列表<ul>
<li>&lt; ol&gt;</li>
<li>&lt; li&gt;</li>
</ul>
</li>
<li>无序列表<ul>
<li>&lt; ul&gt;</li>
<li>&lt; li&gt;</li>
</ul>
</li>
</ul>
<h3 id="5-链接标签"><a href="#5-链接标签" class="headerlink" title="5.链接标签"></a>5.链接标签</h3><ul>
<li>&lt; a&gt;：定义一个超链接<ul>
<li>属性：<ul>
<li>href：指定访问资源的URL</li>
<li>target：<ul>
<li>_blank    在新窗口中打开被链接文档。</li>
<li>_self    默认。在相同的框架中打开被链接文档。</li>
<li>_parent    在父框架集中打开被链接文档。</li>
<li>_top    在整个窗口中打开被链接文档。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-表格标签"><a href="#6-表格标签" class="headerlink" title="6.表格标签"></a>6.表格标签</h3><ul>
<li>&lt; table&gt;：定义表格<ul>
<li>width：宽度</li>
<li>border：边框</li>
<li>cellpadding：定义内容和单元格的距离。</li>
<li>cellspacing：定义单元格之间的距离，如果为0，则边框线合为一体只有一条。</li>
<li>bgcolor：背景色</li>
</ul>
</li>
<li>&lt; td&gt;：定义单元格<ul>
<li>colspan：合并列</li>
<li>rowspan：合并行</li>
</ul>
</li>
<li>&lt; tr&gt;：定义行</li>
<li>&lt; th&gt;：定义表头单元格</li>
<li>&lt; caption&gt;：表格标题</li>
<li>&lt; thead&gt;：表示表格的头部分</li>
<li>&lt; tbody&gt;：表示表格的体部分</li>
<li>&lt; tfoot&gt;：表示表格的脚部分</li>
</ul>
<h3 id="7-div和span标签"><a href="#7-div和span标签" class="headerlink" title="7.div和span标签"></a>7.div和span标签</h3><ul>
<li>&lt; span&gt;:文本信息在一行展示，行内标签，内联标签。</li>
<li>&lt; div&gt;:每一个div占满一整行。块级标签。</li>
</ul>
<h3 id="8-语义化标签"><a href="#8-语义化标签" class="headerlink" title="8.语义化标签"></a>8.语义化标签</h3><p>html5中为了提高程序的可读性，提供了一些标签。</p>
<ul>
<li>&lt; header&gt;</li>
<li>&lt; footer&gt;</li>
<li>……</li>
</ul>
<h3 id="9-表单标签"><a href="#9-表单标签" class="headerlink" title="9.表单标签"></a>9.表单标签</h3><ul>
<li><p>表单：用于采集用户输入的数据的。用于和服务器进行交互。</p>
</li>
<li><p>&lt; form&gt;：表单标签</p>
<ul>
<li><p>属性：</p>
<ul>
<li>action：指定提交数据的URL</li>
<li>method：指定提交方式<ul>
<li>分类：一共七种，常用的有两种<ul>
<li>get：请求参数会在地址栏中显示。请求参数的长度有限制。不太安全。</li>
<li>post：请求参数不会在地址栏中显示。会封装在请求体中。请求参数长度没有限制。较为安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表单项中的数据想要被提交，必须指定其name属性</p>
</li>
</ul>
</li>
<li><p>表单项标签</p>
<ul>
<li><p>&lt; input&gt;：可以通过type属性值，改变元素展示的样子</p>
<ul>
<li><p>type属性：</p>
<ul>
<li>text；文本输入框(默认值)<ul>
<li>placeholder：指定输入框的提示信息，当有输入时，清空提示信息。</li>
</ul>
</li>
<li>password：密码输入框</li>
<li>radio：单选框<ul>
<li><strong>注意：</strong><ol>
<li>让多个单选框实现单选的效果，则多个单选框的name值必须一样。</li>
<li>一般会给每一个单选框提供value值，指定其被选中后提交的值。</li>
<li>checked属性可以指定默认选中的值。</li>
</ol>
</li>
</ul>
</li>
<li>checkbox：复选框<ul>
<li><strong>注意：</strong><ol>
<li>一般会给每一个单选框提供value值，指定其被选中后提交的值。</li>
<li>checked属性可以指定默认选中的值。</li>
</ol>
</li>
</ul>
</li>
<li>file：文件选择框</li>
<li>hidden：隐藏域，用于提交一些信息</li>
<li>submit：提交按钮</li>
<li>button：普通按钮</li>
<li>image：图片提交按钮，通过src指定图片路径</li>
</ul>
</li>
<li><p>&lt; label&gt;：指定输入项的文字描述信息</p>
<ul>
<li>label的for属性，一般会和input的id属性对应，点击label区域，会让input输入框获得焦点。</li>
</ul>
</li>
</ul>
</li>
<li><p>&lt; select&gt;：下拉列表</p>
<ul>
<li>子元素：&lt; option&gt;：指定列表项</li>
</ul>
</li>
<li><p>textarea：文本域</p>
<ul>
<li>cows：指定列数</li>
<li>rows：指定行数</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2020/04/27/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><ul>
<li><p><strong>概念：</strong> Java DataBase Connectivity Java 数据库连接，Java语言操作数据库。</p>
</li>
<li><p><strong>JDBC本质：</strong> 其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
</li>
</ul>
<h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h2><ul>
<li>步骤：<ol>
<li>导入驱动jar包<ol>
<li>复制mysql-connector-java-8.0.20.jar到项目中自己创建的文件夹下，用于存放各种所需要用到的jar包的文件夹。</li>
<li>右键 –&gt; Add As Library</li>
</ol>
</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection<ul>
<li><strong>注意：新版本的jdbc需要在url后边加上?serverTimezone=GMT，否则会报错，因为数据库和系统时区差异。</strong></li>
</ul>
</li>
<li>定义sql</li>
<li>获取执行sql语句执行对象 Statement</li>
<li>执行sql，接收返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-详解各个对象"><a href="#2-详解各个对象" class="headerlink" title="2.详解各个对象"></a>2.详解各个对象</h2><h3 id="1-DriverManager：驱动管理对象"><a href="#1-DriverManager：驱动管理对象" class="headerlink" title="1.DriverManager：驱动管理对象"></a>1.DriverManager：驱动管理对象</h3><ul>
<li><p>功能</p>
<ol>
<li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar包</p>
<ul>
<li><p><code>static void registerDriver​(Driver driver)</code> 使用 DriverManager注册给定的驱动程序。</p>
</li>
<li><p>写代码使用：<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></p>
</li>
<li><p>通过查看源码发现，com.mysql.cj.jdbc.Driver类中包含一个静态代码块，其中静态代码块包含的内容中就是<code>static void registerDriver​(Driver driver)</code>。</p>
</li>
<li><p><strong>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</strong></p>
</li>
</ul>
</li>
<li><p>获取数据库连接</p>
<ul>
<li>方法：<code>static Connection getConnection​(String url, String user, String password)</code></li>
<li>参数：<ul>
<li>url：指定连接的路径<ul>
<li>语法：jdbc:mysql://ip地址（域名）:端口号/数据库名称?serverTimezone=GMT</li>
<li><strong>如果连接的是本机的一个mysql服务器，并且mysql服务的端口默认是3306，则这个url的ip和端口可以不写。</strong></li>
</ul>
</li>
<li>user：用户名</li>
<li>password：密码</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-Connection：数据库连接对象"><a href="#2-Connection：数据库连接对象" class="headerlink" title="2.Connection：数据库连接对象"></a>2.Connection：数据库连接对象</h3><ul>
<li><p>功能</p>
<ol>
<li><p>获取执行sql的对象</p>
<ul>
<li><code>Statement createStatement​()</code></li>
<li><code>PreparedStatement prepareStatement​(String sql)</code></li>
</ul>
</li>
<li><p>管理事务</p>
<ul>
<li>开启事务 <code>void setAutoCommit​(boolean autoCommit)</code> 参数为false，则为开启事务。</li>
<li>提交事务 <code>void commit​()</code></li>
<li>回滚事务 <code>void rollback​()</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-Statement：执行sql的对象"><a href="#3-Statement：执行sql的对象" class="headerlink" title="3.Statement：执行sql的对象"></a>3.Statement：执行sql的对象</h3><ul>
<li>功能：执行sql<ol>
<li><code>boolean execute​(String sql)</code> 可以执行任意sql语句。</li>
<li><code>int executeUpdate​(String sql)</code> 可以执行DML（insert，update，delete）与DDL（create，alter，drop）语句。<ul>
<li>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功，返回值大于0则执行成功，反之，失败。</li>
</ul>
</li>
<li><code>ResultSet executeQuery​(String sql)</code> 可以执行DQL（select）语句。</li>
</ol>
</li>
</ul>
<h3 id="4-ResultSet：结果集对象"><a href="#4-ResultSet：结果集对象" class="headerlink" title="4.ResultSet：结果集对象"></a>4.ResultSet：结果集对象</h3><ul>
<li>boolean next()：游标向下移动一行。</li>
<li>getXxx(参数)：获取数据。<ul>
<li>Xxx：代表数据类型</li>
<li>参数：<ol>
<li>int：代表列的编号，从1开始。</li>
<li>String：代表列名称。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="5-PreparedStatement：执行sql的对象，功能比Statement更强大"><a href="#5-PreparedStatement：执行sql的对象，功能比Statement更强大" class="headerlink" title="5.PreparedStatement：执行sql的对象，功能比Statement更强大"></a>5.PreparedStatement：执行sql的对象，功能比Statement更强大</h3><ol>
<li><p>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题。</p>
<ol>
<li>输入用户名随便，输入密码：a’ or “a” = ‘a</li>
<li>sql: select * from user where username=’dsadsdcz’ and password=’a’ or ‘a’=’a’;</li>
</ol>
</li>
<li><p>解决SQL注入问题：使用PreparedStatement对象来解决。</p>
</li>
<li><p>预编译的SQL：参数使用？作为占位符。</p>
</li>
<li><p>步骤</p>
<ol>
<li>导入驱动jar包</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql<ul>
<li><strong>注意：sql的参数使用？作为占位符。如<code>select * from user where username=? and password=?;</code></strong></li>
</ul>
</li>
<li>获取执行sql语句的对象PreparedStatement。<code>Connection.PreparedStatement(String sql)</code></li>
<li>给？赋值<ul>
<li>方法：setXxx(参数1，参数2)<ul>
<li>参数1：？的位置编号，从1开始。</li>
<li>参数2：？的值。</li>
</ul>
</li>
</ul>
</li>
<li>执行sql，接收返回结果，不需要传递sql语句</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
</ol>
<ul>
<li><strong>注意：后期都会使用PreparedStatement来完成增删改查的所有操作。因为可以防止SQL注入而且效率更高。</strong></li>
</ul>
<hr>
<h2 id="JDBC工具类：JDBCUtils"><a href="#JDBC工具类：JDBCUtils" class="headerlink" title="JDBC工具类：JDBCUtils"></a>JDBC工具类：JDBCUtils</h2><ul>
<li>目的：简化书写</li>
<li>分析：<ol>
<li>注册驱动。</li>
<li>抽取一个方法获取连接对象。</li>
<li>抽取一个方法释放资源。<ul>
<li>可以不用传递参数，还能保证工具类的通用性，可以使用一个properties配置文件。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="代码实现示例："><a href="#代码实现示例：" class="headerlink" title="代码实现示例："></a>代码实现示例：</h3><ol>
<li><p>properties配置文件：</p>
<pre><code>url= jdbc:mysql://localhost:3306/db2?serverTimezone=GMT
user=root
password=000000
driver=com.mysql.cj.jdbc.Driver</code></pre></li>
<li><p>代码</p>
<pre><code>public class JDBCUtils {

private static String url = null;
private static String user = null;
private static String password = null;
private static String driver = null;

//静态代码块，只执行一次，用于注册驱动和变量的初始化
static {
    try {
        Properties prop = new Properties();
        ClassLoader classLoader = JDBCUtils.class.getClassLoader();
        URL res = classLoader.getResource(&quot;jdbc.properties&quot;);
        String path = res.getPath();
        // 因为我的路径中存在中文，所以需要对其进行编码的处理
        path = URLDecoder.decode(path, StandardCharsets.UTF_8);
        System.out.println(path);
        prop.load(new FileReader(path));
        url = prop.getProperty(&quot;url&quot;);
        user = prop.getProperty(&quot;user&quot;);
        password = prop.getProperty(&quot;password&quot;);
        driver = prop.getProperty(&quot;driver&quot;);
        Class.forName(driver);
    } catch (IOException | ClassNotFoundException e) {
        e.printStackTrace();
    }
}

/**
* 获取连接的方法
* @return Connection对象
* @throws SQLException
*/
public static Connection getConnection() throws SQLException {
    return DriverManager.getConnection(url, user, password);
}

/**
* 资源释放
* @param st
* @param conn
*/
public static void close(Statement st, Connection conn) {
    if (st != null) {
        try {
            st.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
    if (conn != null) {
        try {
            conn.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
}

/**
* 资源释放
* @param st
* @param conn
* @param rs
*/
public static void close(Statement st, Connection conn, ResultSet rs) {
    if (rs != null) {
        try {
            rs.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
    if (st != null) {
        try {
            st.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
    if (conn != null) {
        try {
            conn.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
} 
}</code></pre></li>
</ol>
<hr>
<h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><ol>
<li>使用Connection对象来管理事务<ul>
<li>开启事务 <code>void setAutoCommit​(boolean autoCommit)</code> 参数为false，则为开启事务。在sql执行前开启。</li>
<li>提交事务 <code>void commit​()</code>当所有sql执行完提交事务。</li>
<li>回滚事务 <code>void rollback​()</code>在catch中回滚事务。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL小知识杂谈</title>
    <url>/2020/04/24/SQLkwl/</url>
    <content><![CDATA[<h1 id="SQL的一些小知识"><a href="#SQL的一些小知识" class="headerlink" title="SQL的一些小知识"></a>SQL的一些小知识</h1><hr>
<h2 id="多表关系的实现"><a href="#多表关系的实现" class="headerlink" title="多表关系的实现"></a>多表关系的实现</h2><ol>
<li><p><strong>一对多（多对一）</strong></p>
<ul>
<li>实现方式：在多的一方建立外键，指向一的一方的主键。</li>
</ul>
</li>
<li><p><strong>多对多</strong></p>
<ul>
<li><p>实现方式：需要借助第三张中间表，中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。</p>
</li>
<li><p><em>联合主键：中间表的主键可以是指向另两张表主键的两个外键的联合。例：PRIMARY KEY(rid,uid)；*</em></p>
</li>
</ul>
</li>
<li><p><strong>一对一</strong></p>
<ul>
<li>实现方式：可以在任意一方添加唯一外键指向另一方的主键（一对一关系不常用，如果是一对一，为何不把两张表拼在一起呢）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><p>范式就是设计数据库时需要遵循的一些规范。</p>
<p>范式有<strong>六种</strong>范式：第一范式（1NF），第二范式（2NF），第三范式（3NF），巴斯-科德范式（BCNF），第四范式（4NF），第五范式（5NF，又称完美范式）。</p>
<p><strong>各种范式呈递次规范，越高的范式，数据库冗余越小。一般设计数据库时满足前三范式就可以了。</strong></p>
<h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>每一列都是不可分割的原子数据项。</p>
<h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）。</p>
<p><strong>就是消除部分依赖。</strong></p>
<ul>
<li><p>几个概念</p>
<ol>
<li><p><strong>函数依赖：</strong>A –&gt;B,如果通过A属性（属性组）的值，可以确定唯一B属性的值，则B依赖于A。</p>
<ul>
<li>例：学号 –&gt;姓名   （学号，课程名称） –&gt;分数</li>
</ul>
</li>
<li><p><strong>完全函数依赖：</strong>A –&gt;B,如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。</p>
<ul>
<li>例：（学号，课程名称） –&gt;分数</li>
</ul>
</li>
<li><p><strong>部分函数依赖：</strong>A –&gt;B,如果A是一个属性组，则B属性值的确定需要依赖于A属性组中某一些属性值即可。</p>
<ul>
<li>例：（学号，课程名称） –&gt;姓名</li>
</ul>
</li>
<li><p><strong>传递函数依赖：</strong>A –&gt;B, B –&gt;C，如果通过A属性（属性组）的值，可以确定唯一B属性的值，再通过B属性的值可以确定唯一C属性的值，则称C传递函数依赖于A。</p>
<ul>
<li>例：学号 –&gt;姓名，姓名 –&gt;系主任</li>
</ul>
</li>
<li><p><strong>码：</strong>如果在一张表中，一个属性或属性组，被其他所有属性完全依赖，则称这个属性（属性组）为该表的码。</p>
<ul>
<li>例：（学号，课程名称）</li>
<li>主属性：码属性组中的所有属性</li>
<li>非主属性：去除码属性组中的属性</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。</p>
<p><strong>就是消除传递依赖。</strong></p>
<hr>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="1-内连接查询"><a href="#1-内连接查询" class="headerlink" title="1.内连接查询"></a>1.内连接查询</h3><ol>
<li><p>隐式内连接：使用WHERE条件消除无用数据</p>
<ul>
<li>例：SELECT * FROM emp,dept WHERE emp.id=dept.id;</li>
</ul>
</li>
<li><p>显式内连接：</p>
<ul>
<li>语法<ul>
<li><code>SELECT 字段列表 FROM 表名1 [INNER] JOIN 表名2 ON 条件列表；</code></li>
</ul>
</li>
</ul>
</li>
<li><p>内连接查询：</p>
<ol>
<li>从哪些表中查数据。</li>
<li>条件是什么。</li>
<li>查询哪些字段。</li>
</ol>
</li>
</ol>
<h3 id="2-外连接查询"><a href="#2-外连接查询" class="headerlink" title="2.外连接查询"></a>2.外连接查询</h3><ol>
<li><p>左外连接：</p>
<ul>
<li><p>语法：<code>SELECT 字段名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件列表；</code></p>
</li>
<li><p>查询的是左表（表名1的表）所有数据以及其符合查询条件的交集部分。</p>
</li>
</ul>
</li>
<li><p>右外连接：</p>
<ul>
<li><p>语法：<code>SELECT 字段名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件列表；</code></p>
</li>
<li><p>查询的是右表（表名2的表）所有数据以及其符合查询条件的交集部分。</p>
</li>
</ul>
</li>
</ol>
<h3 id="3-子查询"><a href="#3-子查询" class="headerlink" title="3.子查询"></a>3.子查询</h3><p>就是查询中嵌套查询，被嵌套的查询称为子查询。<br>例：</p>
<pre><code>1. SELECT MAX(salary) FROM emp;
2. SELECT * FROM emp WHERE salary = 9000;

可以替换为子查询
SELECT * FROM emp WHERE salary = (SELECT MAX(salary) FROM emp);</code></pre><ul>
<li><p>子查询的不同情况</p>
<ol>
<li><p>子查询结果是单行单列：</p>
<ul>
<li>子查询可以作为条件，使用运算符去判断。</li>
<li><code>SELECT * FROM emp WHERE salary &lt; (SELECT AVG(salary) FROM emp);</code></li>
</ul>
</li>
<li><p>子查询结果是多行单列：</p>
<ul>
<li>子查询可以作为条件，使用运算符IN去判断。</li>
<li><code>SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);</code></li>
</ul>
</li>
<li><p>子查询结果是多行多列：</p>
<ul>
<li>子查询可以作为一张虚拟表参与查询。</li>
<li><code>SELECT * FROM dept t1, (SELECT * FROM emp WHERE join_date &gt; &#39;2011-11-11&#39;) t2 WHERE t1.id = t2.dept_id;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol>
<li><p>基本介绍</p>
<ol>
<li><p>概念：</p>
<ul>
<li>如果一个包含多个步骤的业务操作，被事务处理，那么这些操作要么同时成功，要么同时失败。</li>
</ul>
</li>
<li><p>操作：</p>
<ol>
<li>开启事务：START TRANSACTION；</li>
<li>回滚：ROLLBACK；</li>
<li>提交：COMMIT；</li>
</ol>
</li>
<li><p>MySQL数据库中事务默认自动提交</p>
<ul>
<li><p>事务提交的两种方式：</p>
<ul>
<li>自动提交：<ul>
<li>MySQL就是自动提交的。</li>
<li>一条DML语句会自动提交一次事务。</li>
</ul>
</li>
<li>手动提交：<ul>
<li>Oracle默认是手动提交的。</li>
<li>需要先开启事务，再提交。</li>
</ul>
</li>
</ul>
</li>
<li><p>修改事务的默认提交方式：</p>
<ul>
<li>查看事务的默认提交方式：<code>SELECT @@AUTOCOMMIT；</code></li>
<li>修改默认提交方式：<code>SET @@AUTOCOMMIT = 0；</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>事务的四大特征</p>
<ol>
<li>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</li>
<li>持久性：当事务提交或者回滚后，数据库将会持保存数据。</li>
<li>隔离性：多个事务之间，相互独立。</li>
<li>一致性：事务操作前后数据总量不变。</li>
</ol>
</li>
<li><p>事务的隔离级别</p>
<ul>
<li><p>概念：多个事务之间，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p>
</li>
<li><p>存在问题：</p>
<ol>
<li>脏读：一个事务读取到另一个事务中没有提交的数据。</li>
<li>不可重复读（虚读）：在同一个事务中两次读取到的数据不一样。</li>
<li>幻读： 一个事务操作(DML)数据表中所有的记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</li>
</ol>
</li>
<li><p>隔离级别</p>
<ol>
<li>read uncommited：读未提交<ul>
<li>产生的问题：脏读，不可重复读，幻读。</li>
</ul>
</li>
<li>read commited：读已提交（Oracle）<ul>
<li>产生的问题：不可重复读，幻读。</li>
</ul>
</li>
<li>repeatable read：可重复读 （MySQL）<ul>
<li>产生的问题：幻读。</li>
</ul>
</li>
<li>serializable：串行化<ul>
<li>可以解决所有 的问题。</li>
</ul>
</li>
</ol>
<ul>
<li>注意：隔离级别从小到大安全性越来越高，但是效率越来越低。</li>
<li>数据库查询隔离级别：<ul>
<li>SELECT @@TX_ISOLATION；</li>
</ul>
</li>
<li>数据库设置隔离级别：<ul>
<li>SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>SQL知识</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的SQL语句</title>
    <url>/2020/04/23/SQL/</url>
    <content><![CDATA[<h1 id="常用的SQL语句"><a href="#常用的SQL语句" class="headerlink" title="常用的SQL语句"></a>常用的SQL语句</h1><hr>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>DDL是操作是数据库和表的SQL语句。</p>
<h3 id="1-操作数据库"><a href="#1-操作数据库" class="headerlink" title="1. 操作数据库"></a>1. 操作数据库</h3><ol>
<li><p><strong>创建</strong></p>
<ul>
<li><p>创建数据库</p>
<ul>
<li>CREATE DATABASE 数据库名称；</li>
</ul>
</li>
<li><p>创建数据库，判断不存在，再创建</p>
<ul>
<li>CREATE DATABASE IF NOT EXISTS 数据库名称；</li>
</ul>
</li>
<li><p>创建数据库，并指定字符集</p>
<ul>
<li>CREATE DATABASE 数据库名称 character set 字符集名；</li>
</ul>
</li>
<li><p>创建数据库，判断不存在，再创建，并指定字符集</p>
<ul>
<li>CREATE DATABASE IF NOT EXISTS 数据库名称 character set 字符集名；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>查询</strong></p>
<ul>
<li><p>查询所有数据库的名称</p>
<ul>
<li>SHOW DATABASES；</li>
</ul>
</li>
<li><p>查询某个数据库的字符集，查询某个数据库的查询语句</p>
<ul>
<li>SHOW CREATE DATABASE 数据库名称；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>修改</strong></p>
<ul>
<li>修改数据库的字符集<ul>
<li>ALTER DATABASE 数据库名称 character set 字符集名；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>删除</strong></p>
<ul>
<li><p>删除数据库</p>
<ul>
<li>DROP DATABASE 数据库名称；</li>
</ul>
</li>
<li><p>判断数据库存在，再删除</p>
<ul>
<li>DROP DATABASE IF EXISTS 数据库名称；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用数据库</strong></p>
<ul>
<li><p>查询当前正在使用的数据库名称</p>
<ul>
<li>SELECT DATABASE();</li>
</ul>
</li>
<li><p>使用数据库</p>
<ul>
<li>USE 数据库名称；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-操作表"><a href="#2-操作表" class="headerlink" title="2. 操作表"></a>2. 操作表</h3><ol>
<li><p><strong>创建</strong></p>
<ul>
<li><p>创建表</p>
<pre><code>CREATE TABLE 表名称(
    列名1，数据类型1，
    列名2，数据类型2，
    列名3，数据类型3，
    .......
    列名n，数据类型n
)；</code></pre></li>
<li><p><strong>注意最后一列后面不用加逗号</strong></p>
</li>
<li><p>SQL中常用的数据类型</p>
<ol>
<li>int：整数类型</li>
<li>double：小数类型</li>
<li>date：日期，只包含年月日，yyyy-MM-dd</li>
<li>datetime：日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss</li>
<li>timestamp：时间戳类型，包含年月日时分秒，不赋值时可以默认添加当前系统时间</li>
<li>varchar：字符串</li>
</ol>
</li>
<li><p>复制表</p>
<ul>
<li>CREATE TABLE 表名 LIKE 被复制的表名；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>查询</strong></p>
<ul>
<li>查询某个数据库中所有表的名称<ul>
<li>SHOW TABLES；</li>
</ul>
</li>
<li>查询表结构<ul>
<li>DESC 表名称；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>修改</strong></p>
<ul>
<li><p>修改表名</p>
<ul>
<li>ALTER TABLE 表名称 RENAME TO 新的表名；</li>
</ul>
</li>
<li><p>修改表的字符集</p>
<ul>
<li>ALTER TABLE 表名称 character set 字符集名；</li>
</ul>
</li>
<li><p>添加一列</p>
<ul>
<li>ALTER TABLE 表名称 ADD 列名 数据类型；</li>
</ul>
</li>
<li><p>修改列名和类型</p>
<ul>
<li>ALTER TABLE 表名称 CHANGE 列名 新列名 新数据类型；</li>
<li>ALTER TABLE 表名称 MODIFY 列名 新数据类型；</li>
</ul>
</li>
<li><p>删除列</p>
<ul>
<li>ALTER TABLE 表名称 DROP 列名；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>删除</strong></p>
<ul>
<li><p>删除表</p>
<ul>
<li>DROP TABLE 表名称；</li>
</ul>
</li>
<li><p>判断表存在，再删除</p>
<ul>
<li>DROP TABLE IF EXISTS 表名称；</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>DML是增删改数据库的表中的数据的SQL语句。</p>
<ol>
<li><p><strong>添加数据</strong></p>
<ul>
<li><p>INSERT INTO 表名(列名1，列名2，列名3，…..列名n) VALUES(值1，值2，值3，…..值n);</p>
</li>
<li><p><strong>注意：</strong></p>
</li>
</ul>
<ol>
<li><p>列名和值要一一对应。</p>
</li>
<li><p>如果表名后，不定义列名，则默认给所有列添加值。</p>
<ul>
<li>INSERT INTO 表名VALUES(值1，值2，值3，…..值n);</li>
</ul>
</li>
<li><p>除了数字类型，其他类型需要使用引号（单双引号都可以）引起来。</p>
</li>
</ol>
</li>
<li><p><strong>删除数据</strong></p>
<ul>
<li><p>DELETE FROM 表名 [WHERE 条件]；</p>
</li>
<li><p><strong>注意：如果不加条件，则删除表中所有记录。</strong></p>
</li>
<li><p><strong>如果要删除表中所有记录，不推荐使用<code>DELETE FROM 表名；</code>，可以使用<code>TRUNCATE TABLE 表名；</code>。</strong></p>
</li>
</ul>
</li>
<li><p><strong>修改数据</strong></p>
<ul>
<li><p>UPDATE 表名 SET 列名1=值1， 列名2=值2，….列名n=值n [WHERE 条件]；</p>
</li>
<li><p><strong>注意：如果不加任何条件，则会将表中所有记录修改。</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p>DQL是查询表中记录的SQL语句。</p>
<ul>
<li>SELECT * FROM 表名；</li>
</ul>
<p><strong>语法：</strong></p>
<pre><code>SELECT
    字段列表
FROM
    表名列表
WHERE
    条件列表
GROUP BY
    分组字段
HAVING
    分组之后的条件
ORDER BY
    排序
LIMIT
    分页限定</code></pre><h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1. 基础查询"></a>1. 基础查询</h3><ol>
<li><p>多个字段的查询</p>
<ul>
<li>SELECT 字段名1，字段名2… FROM 表名；</li>
</ul>
</li>
<li><p>去除重复</p>
<ul>
<li>SELECT DISTINCT 字段名1，字段名2… FROM 表名；</li>
</ul>
</li>
<li><p>计算列</p>
<ul>
<li>一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</li>
<li>IFNULL（表达式1，表达式2）：NULL参与的运算，计算结果都为NULL。<ul>
<li>表达式1：哪个字段需要判断是否为NULL。</li>
<li>表达式2：如果该字段为NULL后的替换值。</li>
</ul>
</li>
</ul>
</li>
<li><p>起别名</p>
<ul>
<li><p>SELECT 字段名1 AS 别名 FROM 表名；</p>
</li>
<li><p><strong>注意：AS也可以省略，用一个空格代替。</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2. 条件查询"></a>2. 条件查询</h3><ol>
<li><p>WHERE子句后跟条件。</p>
</li>
<li><p>运算符</p>
<ul>
<li>&lt; &gt; &gt;= &lt;= &lt;&gt; =</li>
<li>BETWEEN…AND</li>
<li>IN(集合)</li>
<li>LIKE：模糊查询<ul>
<li>占位符：<ul>
<li>_：单个任意字符。</li>
<li>%：多个任意字符。</li>
</ul>
</li>
</ul>
</li>
<li>IS NULL</li>
<li>AND 或 &amp;&amp;</li>
<li>OR 或 ||</li>
<li>NOT 或 ！</li>
</ul>
</li>
</ol>
<h3 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3. 排序查询"></a>3. 排序查询</h3><ul>
<li><p><strong>语法</strong></p>
<ul>
<li>ORDER BY 排序字段1 排序方式1，排序字段2 排序方式2….</li>
</ul>
</li>
<li><p><strong>排序方式</strong></p>
<ul>
<li><p>ASC：升序，默认的。</p>
</li>
<li><p>DESC：降序。</p>
</li>
<li><p><strong>注意：如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4. 聚合函数"></a>4. 聚合函数</h3><blockquote>
<p>将一列数据作为一个整体，进行纵向的计算。</p>
</blockquote>
<p><strong><em>注意：聚合函数的计算会排除NULL值</em></strong></p>
<p><strong><em>解决方案：1.选择不包含空的列（主键）进行计算。2.IFNULL函数。</em></strong></p>
<ol>
<li><strong>COUNT；计算个数。</strong><ul>
<li>SELECT COUNT(字段名) FROM 表名；</li>
</ul>
</li>
<li><strong>MAX；计算最大值。</strong><ul>
<li>SELECT MAX(字段名) FROM 表名；</li>
</ul>
</li>
<li><strong>MIN；计算最小值。</strong><ul>
<li>SELECT MIN(字段名) FROM 表名；</li>
</ul>
</li>
<li><strong>SUM：计算和。</strong><ul>
<li>SELECT SUM(字段名) FROM 表名；</li>
</ul>
</li>
<li><strong>AVG；计算平均值。</strong><ul>
<li>SELECT AVG(字段名) FROM 表名；</li>
</ul>
</li>
</ol>
<h3 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5. 分组查询"></a>5. 分组查询</h3><ul>
<li><p><strong>语法：</strong></p>
<ul>
<li>GROUP BY 分组字段；</li>
<li>SELECT 分组字段, 聚合函数1，…. FROM 表名 GROUP BY 分组字段;</li>
</ul>
</li>
<li><p><strong><em>注意：1.分组之后查询的字段只能是分组字段或者聚合函数。2.在分组之前可以用WHERE进行条件限定且后面不可以跟聚合函数判断，如果要在分组之后进行条件限定需要用HAVING且后面可以跟聚合函数判断。</em></strong></p>
<p>  <code>SELECT 分组字段, 聚合函数1，.... FROM 表名 WHERE 条件 GROUP BY 分组字段 HAVING 条件;</code></p>
</li>
</ul>
<h3 id="6-分页查询"><a href="#6-分页查询" class="headerlink" title="6. 分页查询"></a>6. 分页查询</h3><ul>
<li><strong>语法：</strong><ul>
<li>LIMIT 开始的索引，每页查询的条数；</li>
<li>SELECT * FROM 表名 LIMIT 开始的索引, 每页查询的条数;</li>
</ul>
</li>
</ul>
<p><strong><em>LIMIT是一个“方言”，只能在MySQL中用。</em></strong></p>
<hr>
<h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="1-管理用户"><a href="#1-管理用户" class="headerlink" title="1.管理用户"></a>1.管理用户</h3><ol>
<li><p>添加用户：</p>
<ul>
<li>CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’；</li>
</ul>
</li>
<li><p>删除用户：</p>
<ul>
<li>DROP USER ‘用户名‘@’主机名’；</li>
</ul>
</li>
<li><p>修改用户密码：</p>
<ul>
<li><p>UPDATE USER SET PASSWORD = PASSWORD(‘新密码’) WHERE USER = ‘用户名’；</p>
</li>
<li><p>SET PASSWORD FOR ‘用户名‘@’主机名’ = PASSWORD(‘新密码’)；</p>
</li>
<li><p><strong>MySQL中忘记了root用户的密码怎么办？</strong></p>
<ol>
<li>cmd –&gt; net stop mysql80 停止mysql服务</li>
<li>使用无验证方式启动mysql服务：mysqld –skip-grant-tables</li>
<li>打开新的cmd窗口，直接输入mysql命令，敲回车，就可以登陆成功</li>
<li>USE mysql；</li>
<li>UPDATE USER SET PASSWORD = PASSWORD(‘新密码’) WHERE USER = ‘root’；</li>
<li>关闭两个窗口</li>
<li>打开任务管理器，手动关闭mysqld.exe的进程</li>
<li>启动mysql服务</li>
<li>使用新密码登录</li>
</ol>
</li>
</ul>
</li>
<li><p>查询用户：</p>
<ol>
<li>切换到mysql数据库。<code>USE mysql;</code></li>
<li>查询user表。<code>SELECT * FROM user;</code></li>
</ol>
<ul>
<li>通配符：%表示可以在任意主机使用用户登录数据库。</li>
</ul>
</li>
</ol>
<h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2.权限管理"></a>2.权限管理</h3><ol>
<li><p>查询权限：</p>
<ul>
<li>SHOW GRANTS FOR ‘用户名‘@’主机名’;</li>
</ul>
</li>
<li><p>授予权限</p>
<ul>
<li>GRANT 权限列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;</li>
<li>GRANT ALL ON <em>.</em> TO ‘用户名‘@’主机名’; 给一个用户授予对任意数据库中任意表进行任意操作的权限。</li>
</ul>
</li>
<li><p>撤销权限</p>
<ul>
<li>REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’;</li>
</ul>
</li>
</ol>
<hr>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p>
<p>分类：</p>
<ol>
<li>主键约束：primary key</li>
<li>非空约束：not null</li>
<li>唯一约束：unique</li>
<li>外键约束：foreign key</li>
</ol>
<h3 id="1-非空约束"><a href="#1-非空约束" class="headerlink" title="1.非空约束"></a>1.非空约束</h3><p>某一列的值不能为NULL。</p>
<ul>
<li><p>创建表时添加非空约束</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2 NOT NULL，
    .....
);</code></pre></li>
<li><p>创建表完后添加非空约束</p>
<p>  <code>ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL；</code></p>
</li>
<li><p>删除非空约束</p>
<p>  <code>ALTER TABLE 表名 字段名 数据类型；</code></p>
</li>
</ul>
<h3 id="2-唯一约束"><a href="#2-唯一约束" class="headerlink" title="2.唯一约束"></a>2.唯一约束</h3><p>某一列的值不能重复。</p>
<ul>
<li><p>创建表时，添加唯一约束</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2 UNIQUE，
    .....
);</code></pre></li>
<li><p>删除唯一约束</p>
<p>  <code>ALTER TABLE 表名 DROP INDEX 字段名；</code></p>
</li>
<li><p>在表创建完后，添加唯一约束</p>
<p>  <code>ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE；</code></p>
</li>
</ul>
<h3 id="3-主键约束"><a href="#3-主键约束" class="headerlink" title="3.主键约束"></a>3.主键约束</h3><p>某一列的值非空且唯一，一张表只能有一个字段为主键，就是表中记里的唯一标识。</p>
<ul>
<li><p>创建表时，添加主键约束</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2 PRIMARY KEY，
    .....
);</code></pre></li>
<li><p>删除主键</p>
<p>  <code>ALTER TABLE 表名 DROP PRIMARY KEY；</code></p>
</li>
<li><p>创建完表后，添加主键</p>
<p>  <code>ALTER TABLE 表名 MODIFY 字段名 数据类型 PRMARY KEY；</code></p>
</li>
<li><p>自动增长</p>
<ul>
<li><p>如果某一列是数值类型，使用AUTO_INCREMENT可以完成值自动增长，一般可以配合数值类型的主键使用。</p>
</li>
<li><p><strong>注意：自动增长的值为最后一条记录自动增长字段的值加一</strong></p>
</li>
<li><p>创建表时，添加主键，并且完成自动增长</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2 PRIMARY KEY AUTO_INCREMENT，
    .....
);</code></pre></li>
<li><p>删除自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 字段名 数据类型；</code></p>
</li>
<li><p>添加自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 字段名 数据类型 AUTO_INCREMENT；</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-外键约束"><a href="#4-外键约束" class="headerlink" title="4.外键约束"></a>4.外键约束</h3><p>让表与表产生关系，从而保证数据的正确性，外键可以为NULL，但是不能是主表中不存在的值。</p>
<ul>
<li><p>创建表时，添加外键</p>
<pre><code>CREATE TABLE 表名(
    字段名1 数据类型1，
    字段名2 数据类型2，
    .....
    CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称)
);</code></pre></li>
<li><p>删除外键</p>
<p>  <code>ALTER TABLE 表名称 DROP FOREIGN KEY 外键名称；</code></p>
</li>
<li><p>创建表之后，添加外键</p>
<p>  <code>ALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称)；</code></p>
</li>
<li><p>级联操作</p>
<p>  可以在外键关联的主表中的列进行操作时，外键中的值自动更新。</p>
<ul>
<li><p>级联更新</p>
<ul>
<li><p>在添加外键语句后加上ON UPDATE CASCADE</p>
<p><code>ALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE；</code></p>
</li>
</ul>
</li>
<li><p>级联删除</p>
<ul>
<li><p>在添加外键语句后加上ON DELETE CASCADE</p>
<p><code>ALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称) ON DELETE CASCADE；</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><em>级联更新与级联删除可以同时存在。</em></strong></p>
<hr>
<h2 id="命令行操作数据库备份和还原"><a href="#命令行操作数据库备份和还原" class="headerlink" title="命令行操作数据库备份和还原"></a>命令行操作数据库备份和还原</h2><ul>
<li><p>备份：MYSQLDUMP -u用户名 -p密码 数据库名称 &gt; 保存的路径；</p>
</li>
<li><p>还原：</p>
<ol>
<li>登录数据库</li>
<li>创建数据库</li>
<li>使用数据库</li>
<li>使用文件。SOURCE 文件路径</li>
</ol>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>SQL语句</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>杂谈：权限修饰符，匿名内部类....</title>
    <url>/2020/04/15/Inner/</url>
    <content><![CDATA[<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p><strong>JAVA中有四种权限修饰符：public，protected，（default），private。</strong></p>
<p><strong>四种权限修饰符权限大小：public &gt; protected &gt; （default） &gt; private</strong></p>
<p><strong><em>注意：（default）代表什么也不加，例：class person。</em></strong></p>
<blockquote>
<p>权限修饰符在不同范围的权限</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">(default)</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同一个类</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="left">同一个包</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">No</td>
</tr>
<tr>
<td align="left">不同包子类</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">No</td>
</tr>
<tr>
<td align="left">不同包非子类</td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">No</td>
<td align="center">No</td>
</tr>
</tbody></table>
<hr>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>如果一个事物内部包含另一个事物，那么这就是一个类包含另一个类。</p>
<p>如：身体和心脏的关系，汽车和发动机的关系</p>
<p>分类：</p>
<ol>
<li>成员内部类</li>
<li>局部内部类（其中包含匿名内部类）</li>
</ol>
<hr>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类的定义格式：</p>
<pre><code>修饰符 class 外部类名称{
    修饰符 class 内部类名称{
        ....
    }
    .....
}</code></pre><p><strong><em>注意：内用外，可以随意访问；外用内，需要借助内部类对象。</em></strong></p>
<p>如何使用成员内部类？</p>
<ol>
<li><p>间接方式：在外部类的成员方法中，使用内部类，然后main只是调用外部类的方法。</p>
</li>
<li><p>直接方式：公式</p>
</li>
</ol>
<p><strong>外部类名称.内部类名称 对象名 = new 外部类名称（）.new 内部类名称（）；</strong>。</p>
<p>注意：内部类访问重名的外部类成员变量：<strong>外部类名称.this.成员变量名称</strong>。</p>
<hr>
<h3 id="局部内部类（匿名内部类）"><a href="#局部内部类（匿名内部类）" class="headerlink" title="局部内部类（匿名内部类）"></a>局部内部类（匿名内部类）</h3><p>如果<strong>一个类定义在一个方法内部</strong>，那么这就是一个局部内部类。</p>
<p>“局部”：只有当前所属的方法能使用它，出了这个方法外面就不能用了。</p>
<p>定义格式：</p>
<pre><code>修饰符 class 外部类名称 {
    修饰符 返回值类型 外部类方法名称（参数列表） {
        class 局部内部类名称 {
            ....
        }
    }
    .....
}</code></pre><blockquote>
<p>定义一个类的时候，权限修饰符规则：</p>
</blockquote>
<ol>
<li>外部类：public/（default）</li>
<li>成员内部类：public/protected/（default）/private</li>
<li>局部内部类：什么也不写</li>
</ol>
<p>局部内部类：如果希望<strong>访问所在方法的局部变量</strong>，那么这个局部变量必须是<strong>有效final的</strong>。</p>
<p><strong><em>备注：从java8开始，只要局部变量事实不变，那么final关键字可以省略。</em></strong></p>
<blockquote>
<p>原因：</p>
</blockquote>
<ol>
<li>new出来的对象在堆内存当中。</li>
<li>局部变量跟着方法走，在栈内存当中。</li>
<li>方法运行结束之后，立刻出栈，局部变量就会消失。</li>
<li>但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。</li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类也是一种局部内部类。</p>
<p>如果接口的实现类（或者是父类的子类）<strong>只需使用唯一的一次，</strong> 那么这种情况下就可以省略掉这类的定义，而改为使用<strong>匿名内部类</strong>。</p>
<p>匿名内部类的定义格式：</p>
<pre><code>接口名称 对象名 = new 接口名称（） {
    //覆盖重写所有抽象方法
}</code></pre><p><strong><em>注意：匿名内部类，在创建对象的时候，只能使用唯一一次。</em></strong></p>
<p>如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。</p>
<hr>
<p>以上就是关于内部类的一些简要描述，如需知道更多请自己查询。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中关于时间的一些类</title>
    <url>/2020/04/15/Date/</url>
    <content><![CDATA[<h2 id="Calendar日历类"><a href="#Calendar日历类" class="headerlink" title="Calendar日历类"></a>Calendar日历类</h2><p>java.util.Calendar:日历类</p>
<p>Calendar类是一个抽象类，里面提供了很多操作<strong>日历字段</strong>的方法：（YEAR,MONTH,DAY_OF_MONTH,HOUR）。</p>
<p>Calendar类是<strong>无法直接创建对象使用的</strong>，里面有一个<strong>静态方法</strong>叫<strong>getInstance（）</strong>，该方法返回了Calendar类的<strong>子类对象</strong>。</p>
<p><code>static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历。</p>
<p><strong>Calendar类的常用成员方法：</strong></p>
<ol>
<li><p><code>public int get(int field)</code>：返回给定日历字段的值。</p>
</li>
<li><p><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</p>
</li>
<li><p><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</p>
</li>
<li><p><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</p>
</li>
</ol>
<p><strong>成员方法的参数：</strong></p>
<pre><code>int field：日历类的字段，可以使用Calendar类的静态成员变量获取。
public static final int YEAR = 1;           年
public static final int MONTH = 2;          月
public static final int DATE = 5;           月中的某一天
public static final int DAY_OF_MONTH = 5;   月中的某一天
public static final int HOUR = 10;          时
public static final int MINUTE = 12;        分
public static final int SECOND = 13;        秒</code></pre><hr>
<h2 id="Date日期类"><a href="#Date日期类" class="headerlink" title="Date日期类"></a>Date日期类</h2><p>java.util.Date:表示日期和时间的类</p>
<p>类Date表示特定的瞬间，精确到毫秒。</p>
<blockquote>
<p>毫秒：千分之一秒  1000毫秒等于一秒。</p>
</blockquote>
<blockquote>
<p>特定的瞬间：一个时间点，一刹那时间。</p>
</blockquote>
<p>毫秒值的作用：可以对时间和日期进行计算。</p>
<blockquote>
<p>2088-01-05到20-99-03-05到底有多少天？<br>  可以日期转换为毫秒进行计算，计算完毕，再把毫秒转换为日期。</p>
</blockquote>
<p><strong>把日期转换为毫秒：</strong><br>当前的日期：2088-01-01</p>
<p>时间原点（0毫秒）：1970年1月1日 00：00：00（英国格林威治）。</p>
<p>就是计算当前日期到时间原点之间一共经历了多少毫秒。</p>
<p><strong><em>注意：中国是东八区，所以会把时间增加八个小时，即从早上8点开始。</em></strong></p>
<p><strong>把毫秒转换为日期：</strong><br>1 天 = 24 X 60 X 60 = 86400 秒 = 86400 X 1000 = 86400000毫秒。</p>
<p><strong>Date类的构造方法</strong></p>
<p><code>Date();</code>Date类的无参构造方法,获取当前系统的日期和时间。</p>
<p><code>Date(long time);</code>Date类的有参构造方法，传递毫秒值（long类型），把毫秒值转换为日期。</p>
<p><strong>Date类的常用成员方法</strong></p>
<p><code>long getTime():</code>把日期转换为毫秒值，返回时间原点到现在系统时间之间的毫秒值（相当于System.currentTimeMillis（）；）。</p>
<hr>
<h2 id="DateFormat日期-时间格式化子类的抽象类"><a href="#DateFormat日期-时间格式化子类的抽象类" class="headerlink" title="DateFormat日期/时间格式化子类的抽象类"></a>DateFormat日期/时间格式化子类的抽象类</h2><p>java.text.DateFormat是日期/时间格式化子类的抽象类</p>
<p><strong>作用</strong>：<strong>格式化</strong>（日期 -&gt; 文本）、<strong>解析</strong>（文本-&gt; 日期）。</p>
<p><strong>成员方法：</strong></p>
<pre><code>String format(Date date)：按照指定的模式，把Date日期，格式化为符合模式的字符串。
Date parse(String source)：把符合模式的字符串，解析为一个Date日期。</code></pre><p>DateFormat类是一个<strong>抽象类，无法直接创建对象使用，可以使用DateFormat类的子类。</strong></p>
<p>java.text.SimpleDateFormat <strong>extends DateFormat</strong></p>
<p><strong>构造方法：</strong></p>
<p><code>SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。</p>
<p><strong>参数：</strong>String pattern：传递指定的模式。</p>
<p><strong><em>模式:区分大小写。</em></strong></p>
<pre><code>y  年
M  月
d  日
H  时
m  分
s  秒</code></pre><p>写对应的模式，会把模式替换为对应的日期和时间。</p>
<blockquote>
<p>“yyyy-MM-dd HH-mm-ss”</p>
</blockquote>
<p><strong>注意：</strong>模式中的字母不能更改，但是连接模式的符号可以改变。</p>
<blockquote>
<p>“yyyy年MM月dd日 HH时mm分ss秒”</p>
</blockquote>
<hr>
<p>以上是三个关于时间和日期的类，如需了解更多请自己查询有关内容。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA当中的final关键字</title>
    <url>/2020/04/15/JavaFinal/</url>
    <content><![CDATA[<h2 id="关于final关键字"><a href="#关于final关键字" class="headerlink" title="关于final关键字"></a>关于final关键字</h2><p><strong>final关键字代表最终，不可改变的。</strong></p>
<p>final关键字有常见的四种用法：</p>
<ul>
<li>可以用来修饰一个类</li>
<li>可以用来修饰一个方法</li>
<li>可以用来修饰一个局部变量</li>
<li>可以用来修饰一个成员变量</li>
</ul>
<hr>
<h3 id="用final修饰一个类"><a href="#用final修饰一个类" class="headerlink" title="用final修饰一个类"></a>用final修饰一个类</h3><p>当final关键字用来修饰一个类的时候。</p>
<p>格式：</p>
<pre><code>public final class 类名称 {
        //.....
}</code></pre><p><strong>含义</strong>：当前这个类<strong>不能有任何的子类。（太监类）</strong></p>
<p><strong><em>注意：</em></strong> 一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子），但是可以对父类继承的方法覆盖重写。</p>
<hr>
<h3 id="用final修饰一个方法"><a href="#用final修饰一个方法" class="headerlink" title="用final修饰一个方法"></a>用final修饰一个方法</h3><p>当final关键字来修饰一个方法的时候，这个方法就是<strong>最终方法</strong>，也就是<strong>不能被覆盖重写</strong>。</p>
<p>格式：</p>
<pre><code>修饰符 final 返回值类型 方法名称（参数列表）{
            方法体....
}</code></pre><p><strong><em>注意事项：</em></strong> 对于类、方法来说，<strong>abstract关键字与final关键字不能同时使用，因为矛盾</strong>，</p>
<hr>
<h3 id="用final修饰一个局部变量"><a href="#用final修饰一个局部变量" class="headerlink" title="用final修饰一个局部变量"></a>用final修饰一个局部变量</h3><p><strong>用final修饰局部变量可以不对其进行赋值，那么这个局部变量将会是初始值不能再改变，当然也可以对其赋值，赋值后也不能再改变。</strong></p>
<h3 id="用final修饰一个成员变量"><a href="#用final修饰一个成员变量" class="headerlink" title="用final修饰一个成员变量"></a>用final修饰一个成员变量</h3><p>对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。<strong>但是用final修饰的成员变量一定要对其手动赋值，不会再给默认值了。赋值方法有两种，妖媚直接赋值，要么通过构造方法赋值。</strong></p>
<hr>
<p>此为final关键字的一些粗略简介，更多详细信息请自己查询相关内容。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中的System类与StringBuilder类</title>
    <url>/2020/04/15/SystemStringBuilder/</url>
    <content><![CDATA[<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>java.lang.System类中提供了大量的<strong>静态方法</strong>，可以获取与系统相关的信息或系统级操作。</p>
<p>在System类的API文档中，<strong>常用的方法有：</strong></p>
<p><code>public static long currentTimeMillis();</code> 返回以毫秒为单位的当前时间。</p>
<p><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</code>将数组中指定数据拷贝到另一个数组中。</p>
<pre><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)方法
参数：
    src - 源数组。
    srcPos - 源数组中的起始位置。
    dest - 目标数组。
    destPos - 目标数据中的起始位置。
    length - 要复制的数组元素的数量。</code></pre><hr>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>java.lang.StringBuilder类：字符串缓冲区，可以提高字符串的效率。</p>
<p>构造方法：<br><code>StringBuilder()；</code>构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。</p>
<p><code>StringBuilder(String str)；</code>构造一个字符串生成器，并初始化为指定的字符串内容。</p>
<p><strong>常用的成员方法：</strong><br><code>public StringBuilder append(...)；</code>添加任意类型数据的字符串形式，并返回当前对象自身。</p>
<p><code>public String toString()；</code>将当前的StringBuilder对象转换为String对象。</p>
<p><strong>StingBuilder与String的区别</strong></p>
<p><strong>StringBuilder对象中的内容可以改变，而String不行。</strong></p>
<hr>
<p>以上是关于这两个类的简要描述，如需知道更多请自己查询。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>一些自定义类中的方法重写：toString.....</title>
    <url>/2020/04/15/toString/</url>
    <content><![CDATA[<p>Object类中为我们提供了一些方法，当我们创建自定义类的对象后，想要使用这些方法，可能无法实现我们想要的需求，因此需要我们对Object类的一些方法进行重写。</p>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>如果不重写此方法，直接打印输出时，toString是将其中的地址值转换为字符串，也就是打印出来的是对象的<strong>地址值</strong>，因此需要重写，才能将其中的内容转换为字符串，才能把对象中的内容打印出来。</p>
<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>Object类的equals方法，<strong>默认比较的是两个对象的地址值</strong>，没有意义，所以要重写equals方法，<strong>比较两个对象的属性</strong>。</p>
<p>问题：</p>
<ul>
<li>隐含着一个多态</li>
</ul>
<p><strong><em>多态的弊端：无法使用子类的特有内容（属性和方法）</em></strong></p>
<blockquote>
<p>Object obj = p2 = new Person(“古力娜扎”，19);</p>
</blockquote>
<ul>
<li>解决：可以使用向下转型，把obj类型转换为Person。</li>
</ul>
<hr>
<p><strong><em>这些方法都可以用IDEA的自动代码生成，不用手写</em></strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中的拆装箱</title>
    <url>/2020/04/15/%E6%8B%86%E7%AE%B1%E8%A3%85%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="装箱（拿int类型与Integer类型为例）"><a href="#装箱（拿int类型与Integer类型为例）" class="headerlink" title="装箱（拿int类型与Integer类型为例）"></a>装箱（拿int类型与Integer类型为例）</h2><p>装箱：把基本的数据类型包装到包装类中。</p>
<p><strong>构造方法：</strong></p>
<p><code>Integer(int value)；</code>构造一个新分配的 Integer 对象，它表示指定的 int 值。</p>
<p><code>Integer(String s)；</code>构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。</p>
<p><strong><em>注意：传递的字符串必须是与此包装类相同的基本类型字符串，否则会抛出异常。</em></strong></p>
<p><strong>成员方法：</strong></p>
<p><code>static Integer valueOf(int i)；</code>返回一个表示指定的 int 值的 Integer 实例。</p>
<p><code>static Integer valueOf(String s)</code>；返回保存指定的 String 的值的 Integer 对象。</p>
<hr>
<h2 id="拆箱（拿int类型与Integer类型为例）"><a href="#拆箱（拿int类型与Integer类型为例）" class="headerlink" title="拆箱（拿int类型与Integer类型为例）"></a>拆箱（拿int类型与Integer类型为例）</h2><p>拆箱：在包装类中取出基本类型的数据。</p>
<p><strong>成员方法：</strong><br><code>int intValue()；</code>以 int 类型返回该 Integer 的值。</p>
<hr>
<p>自动装箱与自动拆箱，如：</p>
<p>自动装箱   Integer integer = 1；</p>
<p>自动拆箱   integer = integer + 2;</p>
<p><strong>integer是包装类，无法进行计算，所以自动拆箱了，然后又赋值给integer，自动装箱了。</strong></p>
<p>其他基本类型与包装类之间的装箱拆箱也与此差不多。</p>
<hr>
<p>有关拆箱装箱简要描述，如需知道更多自己查询。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>工具类：Arrays与Math</title>
    <url>/2020/04/04/ArraysAndMath/</url>
    <content><![CDATA[<h2 id="JAVA中的两个工具类：Arrays与Math"><a href="#JAVA中的两个工具类：Arrays与Math" class="headerlink" title="JAVA中的两个工具类：Arrays与Math"></a>JAVA中的两个工具类：Arrays与Math</h2><h3 id="1-Arrays"><a href="#1-Arrays" class="headerlink" title="1. Arrays"></a>1. Arrays</h3><p>  java.util.Arrays是一个与<strong>数组相关</strong>的工具类。里面提供了大量静态方法，用来实现<strong>数组</strong>常见的操作。</p>
<p>  <strong>其中比较常用的方法</strong></p>
<p>  <code>public static String toString(数组)</code></p>
<p>  作用：将参数数组变成字符串（按默认格式：{元素1，元素2，元素3…….}）。</p>
<p>  <code>public static void sort(数组)</code></p>
<p>  作用：按照默认升序对数组进行排序。</p>
<p>  &nbsp; &nbsp;</p>
<h3 id="2-Math"><a href="#2-Math" class="headerlink" title="2. Math"></a>2. Math</h3><p>  java.lang.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学相关运算的操作。</p>
<p>  <strong>其中比较常用的方法</strong></p>
<p>  <code>public static double abs(double num);</code>：获取绝对值。</p>
<p>  <code>public static double ceil(double num);</code>：向上取整。</p>
<p>  <code>public static double floor(double num);</code>：向下取整。</p>
<p>  <code>public static long round(double num);</code>：四舍五入。</p>
<p>  tips： <strong><em>Math.PI代表近似圆周率常量（double）</em></strong></p>
<p>  &nbsp; &nbsp;</p>
<hr>
<p>  &nbsp; &nbsp;</p>
<p>  关于这两个工具类的常用方法简单粗略了写了一下，如过想要了解知道更多，请咨询查找有关信息，<strong>重点记住Arrays是操作数组的工具类，而Math是和数学有关的工具类</strong>。</p>
]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA当中的继承</title>
    <url>/2020/04/04/Extends/</url>
    <content><![CDATA[<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>  在继承的关系中，一个子类就是一个父类，也就是说，子类可以被当作父类看待。</p>
<p>  例如父类是员工，子类是讲师，那么“讲师就是一个员工”。</p>
<h2 id="父类的格式"><a href="#父类的格式" class="headerlink" title="父类的格式"></a>父类的格式</h2><pre><code>public clss 父类名称(){
    // ...
}</code></pre><h2 id="子类的格式"><a href="#子类的格式" class="headerlink" title="子类的格式"></a>子类的格式</h2><pre><code>public class 子类名称 extends 父类名称(){
    //....
}</code></pre><blockquote>
<p>关于继承中的一些注意事项</p>
</blockquote>
<ol>
<li>在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：<ul>
<li>直接通过子类对象访问成员变量：等号左边是谁则优先用谁，没有则向上找。</li>
<li>间接通过成员方法访问成员变量：该方法属于谁就优先用谁，没有则向上找。</li>
</ul>
</li>
<li>子类与父类成员方法重名，创建的对象是谁就优先用谁，否则就向上找。</li>
</ol>
<hr>
<h2 id="继承中对方法进行覆盖重写"><a href="#继承中对方法进行覆盖重写" class="headerlink" title="继承中对方法进行覆盖重写"></a>继承中对方法进行覆盖重写</h2><p><strong>要求</strong></p>
<p>1.字符类<strong>成员方法名称一样，参数列表也一样</strong>，@Override 写在方法前面，用来检测是不是有效的正确覆盖重写。（这个注解要是不写，只要满足要求，也是正确的方法覆盖重写）</p>
<p>2.<strong>子类方法的返回值必须小于等于父类方法的返回值。</strong></p>
<p><strong>例</strong>：父类中返回值类型为String类，子类中为Object类，这样是不行的，子类返回值大于父类。</p>
<p>3.<strong>子类方法的权限必须大于等于父类方法的权限修饰符</strong></p>
<p><strong>注</strong>：public &gt; protected &gt; (default) &gt; private<br>这个(default)不是关键字default，而是代表什么也不写，留空。</p>
<hr>
<h2 id="继承关系中的构造方法"><a href="#继承关系中的构造方法" class="headerlink" title="继承关系中的构造方法"></a>继承关系中的构造方法</h2><p>1.子类构造方法中有一个<strong>默认隐含</strong>的“super()”调用，所以一定是<strong>先调用的父类构造，后执行的子类构造</strong>。</p>
<p>2.可以<strong>通过super关键字来子类构造调用父类重载构造</strong>。</p>
<p>3.<strong>super的父类构造调用，必须是子类构造的第一个语句，不能一个子类构造调用多次super构造</strong>。</p>
<p><strong>父类构造方法</strong></p>
<p><code>public Fu() {System.out.println(&quot;这是一个父类无参构造方法&quot;);}</code></p>
<p><code>public Fu(int num) {System.out.println(&quot;这是一个父类有参构造方法&quot;);}</code></p>
<p><strong>子类构造方法</strong></p>
<pre><code>public Zi(){
    //        super();  //调用父类无参构造方法
    super(20);      //调用父类重载的构造方法
    System.out.println(&quot;这是一个子类构造方法&quot;);
}

 public Zi(int num){
    System.out.println(&quot;这是一个有参子类构造方法&quot;);
}</code></pre><p><strong>主方法</strong></p>
<p><strong><em>输入</em></strong></p>
<p><code>public static void main(String[] args) {Zi zi = new Zi();}</code></p>
<p><strong><em>输出</em></strong></p>
<p>这是一个父类有参构造方法（子类的无参构造中调用了父类的有参构造）</p>
<p>这是一个子类构造方法（子类的无参构造方法）</p>
<p><strong><em>输入</em></strong></p>
<p><code>public static void main(String[] args) {Zi zi = new Zi(10);}</code></p>
<p><strong><em>输出</em></strong></p>
<p>这是一个父类无参构造方法（子类的有参构造方法中默认隐含一个父类的无参构造方法）</p>
<p>这是一个有参子类构造方法（子类的有参构造方法）</p>
<hr>
<h2 id="继承中相关的抽象方法"><a href="#继承中相关的抽象方法" class="headerlink" title="继承中相关的抽象方法"></a>继承中相关的抽象方法</h2><p><strong>抽象方法</strong>：就是加上abstract关键字，然后去掉大括号，直接分号结束。</p>
<p><strong>抽象类</strong>：抽象方法所在的类，必须是抽象类才行，在class前加上abstract关键字即可。</p>
<p><strong><em>如何使用抽象类和抽象方法：</em></strong></p>
<ol>
<li><p>不能直接创建new抽象类对象。</p>
</li>
<li><p>必须用一个子类继承抽象父类。</p>
</li>
<li><p>子类必须覆盖重写父类中的所有抽象方法。</p>
<p>覆盖重写（实现）：去掉abstract关键字，补上{方法体}。</p>
</li>
<li><p>创建子类对象进行使用。</p>
</li>
</ol>
<hr>
<p>以上就是有关于继承的一些知识的简要概述，如需知道更多请自己查询相关资料。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>String字符串</title>
    <url>/2020/04/04/String/</url>
    <content><![CDATA[<h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><h3 id="String字符串的特点"><a href="#String字符串的特点" class="headerlink" title="String字符串的特点"></a>String字符串的特点</h3><ol>
<li>字符串的内容永不可变 。 <strong>重点</strong></li>
<li>正是因为字符串不可变，所以字符串可以共享使用。</li>
<li>字符串效果相当于是char[] 字符数组，但是底层原理是byte[] 字节数组。</li>
</ol>
<p><strong><em>关于字符串内容永不可变</em></strong></p>
<blockquote>
<p>String str = “Hello”；<br>  str实际上是对“Hello”的引用，”Hello”才是在堆中被创建的字符串对象，里面存的的字符串内容是Hello，而str则存放的是Hello这个字符串对象的地址。<br><br>  当出现这种情况时：str = “world”；<br>  原本Hello那个字符串的内容并没有改变，只是在堆中新创建了一个world的字符串对象，而str成了world的引用，存放的是world这个字符串对象的地址。<br>  所以字符串内容是永不可变的，你感觉到的变了其实是引用地址的改变。</p>
</blockquote>
<hr>
<h3 id="创建字符串的常见方式（3-1种）"><a href="#创建字符串的常见方式（3-1种）" class="headerlink" title="创建字符串的常见方式（3+1种）"></a>创建字符串的常见方式（3+1种）</h3><p><strong>三种构造方法</strong></p>
<ol>
<li><p><code>public String();</code> 创建一个空白字符串，不含有任何内容。</p>
</li>
<li><p><code>public String(char[] array);</code> 根据字符数组的内容，来创建对应的字符串。</p>
</li>
<li><p><code>public String(byte[] array);</code> 根据字节数组的内容，来创建对应的字符串。</p>
</li>
</ol>
<p><strong>一种直接创建</strong></p>
<p>String str = “Hello”;</p>
<hr>
<h3 id="String类中常用的一些方法"><a href="#String类中常用的一些方法" class="headerlink" title="String类中常用的一些方法"></a>String类中常用的一些方法</h3><h4 id="与转换相关的方法"><a href="#与转换相关的方法" class="headerlink" title="与转换相关的方法"></a><strong><em>与转换相关的方法</em></strong></h4><p><code>public char[] toCharArray();</code> 将当前字符串拆封为字符数组作为返回值。</p>
<p><code>public byte[] getBytes();</code> 获得当前字符串底层的字节数组。</p>
<p><code>public String replace(CharSequence oldString,CharSequence newString);</code>将所有出现的老字符串替换为新字符串，返回替换之后的结果字符串。CharSequence意思就是说可以接收字符串类型。<strong>游戏中的关键字屏蔽可以用这种方法</strong></p>
<h4 id="与比较相关的方法"><a href="#与比较相关的方法" class="headerlink" title="与比较相关的方法"></a><strong><em>与比较相关的方法</em></strong></h4><p>==用于字符串的比较是对<strong>对象的地址</strong>进行比较，如果要对内容进行比较，可以用下面两个方法。</p>
<p><code>public boolean equals(Object obj);</code> 参数可以是任何对象，只有参数是一个字符串并且内容相同才会返回true，否则返回false。</p>
<blockquote>
<p>“Hello”.equals(str);<br><strong>注意</strong>：这样写比str.equals(“Hello”)好，因为str.equals(“Hello”)可能会抛出空指针异常，str是一个变量，而”Hello”.equals(str)不会抛出这个异常，因为“Hello”是一个常量，永远不会空指针。</p>
</blockquote>
<p><code>public boolean equalsIgnoreCase(String str);</code>忽略大小写进行字符串比较</p>
<blockquote>
<p>str = “ABC”;<br> “abc”.equalsIgnoreCase(str) = true;</p>
</blockquote>
<h4 id="与获取相关的一些方法"><a href="#与获取相关的一些方法" class="headerlink" title="与获取相关的一些方法"></a><strong><em>与获取相关的一些方法</em></strong></h4><p><code>public int length();</code> 获取字符串中字符的个数，拿到字符串长度。</p>
<p><code>public String concat(String str);</code> 将当前字符串和参数字符串拼接成为返回值新的字符串。</p>
<p><code>public char charAt(int index);</code> 获取指定索引位置的单个字符。</p>
<p><code>public int indexOf(String str);</code> 查找参数字符串在本字符串中首次出现的位置，若不存在则返回-1。</p>
<h4 id="字符串的截取方法"><a href="#字符串的截取方法" class="headerlink" title="字符串的截取方法"></a><strong><em>字符串的截取方法</em></strong></h4><p><code>public String substring(int index);</code> 从参数位置开始一直到字符串末尾返回新字符串。</p>
<p><code>public String substring(int begin, int end);</code> 从begin开始一直到end结束返回新字符串，<strong>包括begin不包括end</strong>。</p>
<h4 id="分割字符串的方法"><a href="#分割字符串的方法" class="headerlink" title="分割字符串的方法"></a><strong><em>分割字符串的方法</em></strong></h4><p><code>public String[] split(String regex);</code> 按照参数的规则，将字符串切割成若干部分。</p>
<p>split方法的参数实际上是一个“正则表达式”，如果用英文句点“.”进行切分，<strong>必须写“\\.”</strong>，因为需要转义。</p>
<hr>
<h3 id="基本类型与字符串类型之间的相互转换"><a href="#基本类型与字符串类型之间的相互转换" class="headerlink" title="基本类型与字符串类型之间的相互转换"></a>基本类型与字符串类型之间的相互转换</h3><p>基本类型与字符串类型之间的互相转换。</p>
<p><strong>基本类型–&gt;字符串（String）：</strong></p>
<ol>
<li><p>基本类型的值 + “”。   <strong>最简单的方法，工作中常用</strong>。</p>
</li>
<li><p>包装类的静态方法toString（参数），<strong>不是Object类的toString</strong>。</p>
</li>
</ol>
<p><code>static String toString(包装类的基本类型参数)；</code>返回一个表示指定整数的 String 对象。</p>
<ol start="3">
<li>String类的静态方法valueOf（基本类型参数）；返回参数的字符串表示形式。</li>
</ol>
<p><strong>字符串（String）–&gt;基本类型：</strong></p>
<p>使用包装类的静态方法<strong>parse基本类型名称（字符串）</strong>；</p>
<p><strong>如：Integer类：static int parseInt(String s);</strong></p>
<hr>
<h3 id="关于常量池的概念"><a href="#关于常量池的概念" class="headerlink" title="关于常量池的概念"></a>关于常量池的概念</h3><ol>
<li><p>对于引用类型来说，==进行的是地址值的比较。</p>
</li>
<li><p>双引号直接写的字符串在常量池当中，new的不在池中。</p>
<pre><code>public static void main(String[] args) {
    String str1 = &quot;a,b,c&quot;;
    String str2 = &quot;a,b,c&quot;;

    char[] array = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;};
    String str3 = new String(array);

    System.out.println(str1 == str2);   //true
    System.out.println(str1 == str3);   //false
    System.out.println(str2 == str3);   //false
}</code></pre></li>
</ol>
<p><strong>原理</strong></p>
<p><img src="https://s1.ax1x.com/2020/04/04/G0Yb9O.png" alt="Principle"></p>
<hr>
<p><br>以上是对String字符串类型有关内容的一些小小整理，想要了解更多请自己查询有关知识。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Static静态</title>
    <url>/2020/04/04/Static/</url>
    <content><![CDATA[<h2 id="JAVA中Static的相关内容"><a href="#JAVA中Static的相关内容" class="headerlink" title="JAVA中Static的相关内容"></a>JAVA中Static的相关内容</h2><h3 id="Static的中文意思是静态，什么是静态？"><a href="#Static的中文意思是静态，什么是静态？" class="headerlink" title="Static的中文意思是静态，什么是静态？"></a>Static的中文意思是静态，什么是静态？</h3><p>  <strong>静态就是：</strong></p>
<p>  &nbsp; &nbsp; &nbsp; 如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类，多个对象共享同一份数据，这就是类的<strong>静态变量</strong>。</p>
<p>  &nbsp; &nbsp; &nbsp; 用static修饰的成员方法同理这就是类的<strong>静态方法</strong>。</p>
<blockquote>
<p>注意事项</p>
</blockquote>
<ol>
<li><p><strong><em>静态只能访问静态，静态不能访问非静态。</em></strong> 因为在内存当中，先有的静态内容，后有的非静态内容，先人不知道后人，后人知道先人。</p>
</li>
<li><p><strong><em>静态方法中不能用this。</em></strong> 因为this代表当前对象，通过谁调用的方法，谁就是当前对象，但是静态和对象没关系。</p>
</li>
</ol>
<p>  <strong>关于静态有一种特殊使用方法：静态代码块</strong></p>
<pre><code>public class 类名称 {
    static {
        // 静态代码块的内容
    }
} </code></pre><p>  特点：当第一次用到本类时，静态代码块执行<strong>唯一一次</strong>。当类中某一些只会用到唯一一次的代码，就可以使用静态代码块，无需再将这些代码写成一个方法，然后调用方法执行，静态代码块自己会执行。</p>
<p>  &nbsp; </p>
<hr>
<p>  &nbsp;</p>
<p>  关于静态还有很多需要深入了解的知识，这里只是浅显的讲了一下常用的东西，静态最主要的就是<strong>属于类而和创建的对象无关</strong>。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的接口</title>
    <url>/2020/03/07/JavaInterface/</url>
    <content><![CDATA[<h2 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h2><p>  接口就是多个类的公共规范。</p>
<p>  接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。</p>
<p>  接口与父子类继承有相似之处，可以把接口中的内容交给“实现类”来实现，接口与父子类相比，更加灵活，一个“实现类”可以<strong>多实现</strong>多个接口，而在父子类中只能<strong>单继承</strong>，一个子类只有一个父类。</p>
<h2 id="接口的定义格式"><a href="#接口的定义格式" class="headerlink" title="接口的定义格式"></a>接口的定义格式</h2><pre><code>public interface 接口名称{
    //接口方法
}</code></pre><p><strong><em>接口中的内容</em></strong><br>&nbsp; &nbsp; </p>
<ul>
<li><p>如果是java7，那么接口中可以包含的内容有：</p>
<ol>
<li><p>常量（<strong>必须使用public static final三个关键字修饰，可以省略不写，但是初学者不建议这样做，常量必须有赋值</strong>）</p>
</li>
<li><p>抽象方法（<strong>有abstract关键字修饰</strong>）</p>
</li>
</ol>
</li>
<li><p>如果是java8，还可以额外包含有：</p>
<ol start="3">
<li>默认方法（<strong>可以解决接口升级的问题，即已经有了接口的实现类以后，接口升级不会影响已经使用此接口的实现类</strong>）</li>
<li>静态方法</li>
</ol>
</li>
<li><p>如果是java9，还可以额外包含有：</p>
<ol start="5">
<li>私有方法（<strong>接口中的私有方法用来作为两个方法的公有方法，解决两个方法之间代码重复的问题。但是这个方法不应该让实现类使用，应该是私有的。有普通私有方法与静态私有方法两种，分别解决多个默认方法之间代码重复的问题与多个静态方法之间代码重复的问题</strong>）</li>
</ol>
</li>
</ul>
<p><strong><em>接口的使用步骤</em></strong><br>&nbsp; &nbsp; </p>
<ol>
<li>接口不能直接使用，必须有一个“实现类”来“实现”接口。</li>
</ol>
<p>&nbsp; &nbsp; &nbsp; &nbsp;格式：  </p>
<pre><code>public class 实现类名称 implements 接口名称 {
       //....
}</code></pre><ol start="2">
<li><p>接口的实现类<strong>必须</strong>覆盖重写（实现）接口中所有的抽象方法，如果实现类没有全部覆盖重写，那么实现类<strong>必须</strong>是抽象类。</p>
</li>
<li><p>创建实现类的对象，进行使用。</p>
</li>
</ol>
<h2 id="实现类可以多实现多个接口"><a href="#实现类可以多实现多个接口" class="headerlink" title="实现类可以多实现多个接口"></a>实现类可以多实现多个接口</h2><p>注意事项：<br>&nbsp; &nbsp;</p>
<ol>
<li><p>如果实现类实现的多个接口中，<strong>有重复的抽象方法</strong>，那么只需要覆盖重写<strong>一次</strong>即可。</p>
</li>
<li><p>如果实现类实现的多个接口中，<strong>有重复的默认方法</strong>，那么实现类必须要对重复的默认方法<strong>覆盖重写</strong>。</p>
</li>
<li><p>一个类如果<strong>直接父类中的方法与接口中的默认方法产生了冲突</strong>，优先使用父类当中的方法，<strong>父类的优先级大于接口</strong>。</p>
</li>
</ol>
<h2 id="接口与接口之间也可以多继承"><a href="#接口与接口之间也可以多继承" class="headerlink" title="接口与接口之间也可以多继承"></a>接口与接口之间也可以多继承</h2><p>注意事项：<br>&nbsp; &nbsp;</p>
<ol>
<li><p>多个父接口当中的<strong>抽象方法</strong>如果重复，没关系，因为在子接口当中本就要覆盖重写实现抽象方法。</p>
</li>
<li><p>多个父接口当中的<strong>默认方法</strong>如果重复，那么子接口必须进行默认方法的覆盖重写，而且必须要带着default关键字。</p>
</li>
</ol>
<hr>
<p>更多接口的详细信息可以咨询查找。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList</title>
    <url>/2020/03/06/JavaArrayList/</url>
    <content><![CDATA[<h2 id="Array与ArrayList的区别"><a href="#Array与ArrayList的区别" class="headerlink" title="Array与ArrayList的区别"></a>Array与ArrayList的区别</h2><p> 数组的长度不可以发生改变，但是ArrayList的<strong>长度是可以随意变化的</strong>。</p>
<h2 id="关于ArrayList"><a href="#关于ArrayList" class="headerlink" title="关于ArrayList"></a>关于ArrayList</h2><p>对于ArrayList来说，用一个尖括号<E>代表泛型。</p>
<p><strong>泛型</strong>：就是装在集合当中的所有元素，全都是统一的一种类型。</p>
<p><strong>注意</strong>：泛型 <strong>只能</strong> 是引用类型，<strong>不能</strong> 是基本类型（byte,short,int,long,float,double,boolean,char）</p>
<h2 id="如果想创建一个基本类型的ArrayList"><a href="#如果想创建一个基本类型的ArrayList" class="headerlink" title="如果想创建一个基本类型的ArrayList"></a>如果想创建一个基本类型的ArrayList</h2><p>可以使用基本类型所对应的“包装类”</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类（引用类型）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>Long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>Boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
</tbody></table>
<h2 id="ArrayList的常用方法"><a href="#ArrayList的常用方法" class="headerlink" title="ArrayList的常用方法"></a>ArrayList的常用方法</h2><p><code>public boolean add(E e);</code>  向集合当中添加元素，参数的类型和泛型一致</p>
<p><code>public E get(int index);</code>  从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素</p>
<p><code>public E remove(int index);</code>  从集合当中删除元素，参数是索引编号，返回值就是被删除的元素</p>
<p><code>public int size();</code>  获取集合的尺寸长度，返回值就是集合当中包含的元素的个数</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Random</title>
    <url>/2020/03/06/Random/</url>
    <content><![CDATA[<h2 id="关于Random"><a href="#关于Random" class="headerlink" title="关于Random"></a>关于Random</h2><p>Random类位于java.util.Random包下，可以用来生成随机序列。</p>
<p>有两种常用用法：</p>
<p><code>Random()</code> 用时间作为种子产生随机序列，随机性性强，一般产生的序列不相同。</p>
<p><code>Random(seed)</code> seed是产生随机序列的种子，只要是同一种子，每次产生的随机序列都相同。</p>
<blockquote>
<p>代码举例</p>
</blockquote>
<p>1.第一种方法产生随机序列</p>
<pre><code>Random r = new Random();
int a = nextInt(10);</code></pre><p><strong>10代表产生的随机序在0到10之间（不包括10），即[0,10)。</strong></p>
<hr>
<p>2.第二种方法产生随机序列</p>
<pre><code>Random r = new Random(10);
int a = nextInt(10);</code></pre><p><strong>每次产生的随机序列都相同。</strong></p>
<hr>
<p><em>具体更多用法可以查询API</em></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Scanner</title>
    <url>/2020/03/06/Scanner/</url>
    <content><![CDATA[<h2 id="关于Scanner"><a href="#关于Scanner" class="headerlink" title="关于Scanner"></a>关于Scanner</h2><p>  Scanner的作用类似于输入函数，可以把键盘的输入传递给需要用的变量。</p>
<blockquote>
<p>Scanner的使用步骤</p>
</blockquote>
<h4 id="1-导包"><a href="#1-导包" class="headerlink" title="1.导包"></a>1.导包</h4><p>  <code>import java.util.Scanner;</code></p>
<h4 id="2-创建"><a href="#2-创建" class="headerlink" title="2.创建"></a>2.创建</h4><p>  <code>Scanner sc = new Scanner(System.in);</code></p>
<p>tips：System.in表示从键盘输入。</p>
<h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h4><p><code>String str = sc.next();</code></p>
<p><code>String str = sc.nextLine();</code></p>
<p>对于字符串，有上述两种常用用法，对于第一种，遇到空格就结束，对于第二种遇到回车才结束。</p>
<p><code>String str = sc.nextInt();</code></p>
<p>对于int类型，常用用法如上所写。</p>
<hr>
<p><em>更多详细用法请查询API</em></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>测试1</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
